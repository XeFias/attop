[%
	import "IntermediateGenerator.eol";

	// BAS properties required to generate Markov Automata.
	var rateValues: 		Set(UATV!attributes)	= UATV!Domain.allInstances().select(d|d.name == "lambda").first().attributes;
	var probabilityValues:	Set(UATV!attributes)	= UATV!Domain.allInstances().select(d|d.name == "prob").first().attributes;

	var attackTree:			UATS!AttackTree			= UATS!AttackTree.allInstances().first();
	var rootNode: 			UATS!Node 				= UATS!AttackTree.allInstances().first().Root;

	// Add values to BEs in attack-tree.
	for (node in attackTree.Nodes) {
		node.~values = null;
		if ( node.children.isEmpty() ){ // is BE.
			var prob = probabilityValues.selectOne(a|a.node.id == node.id ).value.value;
			var rate = rateValues.selectOne(a|a.node.id == node.id ).value.value;
			var val:Map(Integer,Real) = Map{	IMA!ValueKeys#PROBABILITY	= prob,
												IMA!ValueKeys#RATE 			= rate };
			node.~values = val;
		}
	}

	var IMA:IMA!InterimAutomaton = generateIntermediateAutomata( attackTree, probabilityValues, rootNode);

@cached
operation UATS!Node getRates() : Sequence {
	var exp : Real = self.getExpRate();
	if (exp > -1)
		return Sequence {exp};
	var attributes = UATV!Attribute.allInstances().select(n | n.node.id == self.id);
	var delayAttrs = attributes.select(a | a.eContainer.purpose.isKindOf(UATV!TimePurpose));
	var expAttrs = delayAttrs.select(a | a.eContainer.purpose.timeType = UATV!TimeType#HYPO_EXPONENTIAL);
	if (expAttrs.isEmpty())
		return Sequence {};
	return expAttrs.first().value.sequence.asSequence();
}

// Returns an associated exponential time, or -1 if there is no such attribute.
@cached
operation UATS!Node getExpRate() {
	var attributes = UATV!Attribute.allInstances().select(n | n.node.id == self.id);
	var delayAttrs = attributes.select(a | a.eContainer.purpose.isKindOf(UATV!TimePurpose));
	var expAttrs = delayAttrs.select(a | a.eContainer.purpose.timeType = UATV!TimeType#EXPONENTIAL);
	if (expAttrs.isEmpty())
		return -1;
	return expAttrs.first().value.value.asReal();
}

%]