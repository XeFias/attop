[%
	import "IntermediateGenerator.eol";

	var attackTree		: UATS!AttackTree	= UATS!AttackTree.allInstances().first();
	var attackTreeValues: UATV!AttackTree	= UATV!AttackTree.allInstances().first();
	var rootNode		: UATS!Node 		= UATS!AttackTree.allInstances().first().Root;
	
	generateIntermediateAutomata(attackTree, rootNode);
	
		
	"_________".println();
	var nodeParamMap : Map;
	var attackTree : UATS!AttackTree = UATS!AttackTree.allInstances().first();
	for(node : UATS!Node in UATS!Node.allInstances()){
		nodeParamMap.put(node.id, new Map());
	}
	for(domain : UATV!Domain in UATV!Domain.allInstances()){
		for(attribute : UATV!Attribute in domain.attributes){
			nodeParamMap.get(attribute.node.id).put(domain.name, attribute.value);
		}
	}
	var bottomUp : Sequence = Sequence {1,2,3};

%]
TODO 1:
des ("0,[%=attackTree.Root.id%],4)";
[%
	//or(node in UATS!Node.allInstances()){
	//	out.print('"'+node.id+'"');
	//	if(node.connector <> null){
	//		if(node.connector.instanceOf(UATS!AND)){
	//			out.print(" and");
	//		} else if(node.connector.instanceOf(UATS!OR)){
	//			out.print(" or");
	//		} else if(node.connector.instanceOf(UATS!KofN)){
	//			out.print(" " + node.connector.Threshold + "of" + node.children.size());
	//		} else if(node.connector.instanceOf(UATS!PAND)){
	//			out.print(" pand");
	//		} else if(node.connector.instanceOf(UATS!SAND)){
	//			out.print(" sand");
	//		} else if(node.connector.instanceOf(UATS!SOR)){
	//			out.print(" sor");
	//		} else if(node.connector.instanceOf(UATS!Spare)){
	//			out.print(" wsp");
	//		}
	//	}
	//	for(child in node.children){
	//		out.print(" \"" + child.id + '"');
	//	}
	//	var params : Map = nodeParamMap.get(node.id);
	//	for(key in params.keySet()){
	//		out.print(" " + key + "=" + params.get(key).value);
	//	}
	//	out.println(";");
	//

@cached
operation UATS!Node getRates() : Sequence {
	var exp : Real = self.getExpRate();
	if (exp > -1)
		return Sequence {exp};
	var attributes = UATV!Attribute.allInstances().select(n | n.node.id == self.id);
	var delayAttrs = attributes.select(a | a.eContainer.purpose.isKindOf(UATV!TimePurpose));
	var expAttrs = delayAttrs.select(a | a.eContainer.purpose.timeType = UATV!TimeType#HYPO_EXPONENTIAL);
	if (expAttrs.isEmpty())
		return Sequence {};
	return expAttrs.first().value.sequence.asSequence();
}

// Returns an associated exponential time, or -1 if there is no such attribute.
@cached
operation UATS!Node getExpRate() {
	var attributes = UATV!Attribute.allInstances().select(n | n.node.id == self.id);
	var delayAttrs = attributes.select(a | a.eContainer.purpose.isKindOf(UATV!TimePurpose));
	var expAttrs = delayAttrs.select(a | a.eContainer.purpose.timeType = UATV!TimeType#EXPONENTIAL);
	if (expAttrs.isEmpty())
		return -1;
	return expAttrs.first().value.value.asReal();
}

%]