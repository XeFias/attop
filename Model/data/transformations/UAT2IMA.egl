[%
	import "IntermediateGenerator.eol";

	var domains : Set(String) = Set{IMA!ValueKeys#RATE,
									IMA!ValueKeys#PROBABILITY,
									IMA!ValueKeys#COST,
									IMA!ValueKeys#TMIN,
									IMA!ValueKeys#TMAX };
									
	var attackTree:	UATS!AttackTree	= UATS!AttackTree.allInstances().first();
	var rootNode:	UATS!Node		= UATS!AttackTree.allInstances().first().Root;
	attackTree.addValuesToAllNodes(domains);

	var IMA:IMA!InterimAutomaton = generateIntermediateAutomata( attackTree, rootNode);

	// Assign all disruptions to the root of IMA
//	IMA.disruptions = IMA!Disruption.allInstances();
//	IMA.disruptions.size().println("IMA.disruptions.size() = ");

/*	for ( d in IMA.disruptions ){
		("disruptions.id = " + d.beId).print();
		(" from: ").print(); 
		if ( d.source <> null) { d.source.id.print(); } else { "null".print();} 
		(" to: ").print(); 
		if ( d.target <> null) { d.target.id.println(); } else { "null".println();} 
	}
*/

	// TODO: Use instanceOf to id gatetypes AND OR SAND SOR.
	
	//or(node in UATS!Node.allInstances()){
	//	out.print('"'+node.id+'"');
	//	if(node.connector <> null){
	//		if(node.connector.instanceOf(UATS!AND)){
	//			out.print(" and");
	//		} else if(node.connector.instanceOf(UATS!OR)){
	//			out.print(" or");
	//		} else if(node.connector.instanceOf(UATS!KofN)){
	//			out.print(" " + node.connector.Threshold + "of" + node.children.size());
	//		} else if(node.connector.instanceOf(UATS!PAND)){
	//			out.print(" pand");
	//		} else if(node.connector.instanceOf(UATS!SAND)){
	//			out.print(" sand");
	//		} else if(node.connector.instanceOf(UATS!SOR)){
	//			out.print(" sor");
	//		} else if(node.connector.instanceOf(UATS!Spare)){
	//			out.print(" wsp");
	//		}
	//	}
	//	for(child in node.children){
	//		out.print(" \"" + child.id + '"');
	//	}
	//	var params : Map = nodeParamMap.get(node.id);
	//	for(key in params.keySet()){
	//		out.print(" " + key + "=" + params.get(key).value);
	//	}
	//	out.println(";");
	//

@cached
operation UATS!Node getRates() : Sequence {
	var exp : Real = self.getExpRate();
	if (exp > -1)
		return Sequence {exp};
	var attributes = UATV!Attribute.allInstances().select(n | n.node.id == self.id);
	var delayAttrs = attributes.select(a | a.eContainer.purpose.isKindOf(UATV!TimePurpose));
	var expAttrs = delayAttrs.select(a | a.eContainer.purpose.timeType = UATV!TimeType#HYPO_EXPONENTIAL);
	if (expAttrs.isEmpty())
		return Sequence {};
	return expAttrs.first().value.sequence.asSequence();
}

// Returns an associated exponential time, or -1 if there is no such attribute.
@cached
operation UATS!Node getExpRate() {
	var attributes = UATV!Attribute.allInstances().select(n | n.node.id == self.id);
	var delayAttrs = attributes.select(a | a.eContainer.purpose.isKindOf(UATV!TimePurpose));
	var expAttrs = delayAttrs.select(a | a.eContainer.purpose.timeType = UATV!TimeType#EXPONENTIAL);
	if (expAttrs.isEmpty())
		return -1;
	return expAttrs.first().value.value.asReal();
}

operation getDomain( domain:String ) : Set(UATV!attributes) {
	var values:		Set(UATV!attributes)	= Set{};
	var domains: 	Sequence(UATV!Domain)	= UATV!Domain.allInstances().select(d|d.name == domain);
	if ( domains.size() > 0 )	{ values = domains.first().attributes; }
	return values; 
}

operation getValue( node, values ) {
	var prob;
	if ( values.size() > 0 ) {
		var probVal = values.selectOne(a|a.node.id == node.id );
		if (probVal <> null) {
			prob = probVal.value.value;
		}
	}
	return prob;
}

operation getValuesPerDomain( domains : Set(String) ) : Map(String, Set(UATV!attributes)) {
	var values : Map(String, Set(UATV!attributes)) = Map{};
	for ( domain in domains ) {
		var domainStr = domain.toString();
		var attributes : Set(UATV!attributes) = getDomain( domainStr );
		values.put( domainStr, attributes);
	}
	return values;
}

// Add all available BE values to the node using epsilons extended expressions node.~values.
operation UATS!AttackTree addValuesToAllNodes( domains : Set(String) ) {
	var values : Map(String, Set(UATV!attributes)) = getValuesPerDomain( domains );
	for ( node in self.Nodes ) {
		node.~values = null;
		if ( node.children.isEmpty() ){ // This is a BE.
			var val:Map(Integer,Real) = Map{};
			for ( domain in domains ) {
				var value = getValue(node, values.get( domain.toString() ) );
				val.put( domain, value );
			}
			node.~values = val;

		}
	}
}

%]