// CAPD *.AUT Example:
//des (0, 4, 4)
//(0, "rate 0.7", 3)
//(0, "rate 0.6", 2)
//(1, "FAIL", 3)
//(2, "rate 0.7", 1)

// Graphviz *.Dot Example:
//digraph BCG {
//size = "7, 10.5";
//center = TRUE;
//node [shape = circle];
//0 [peripheries = 2];
//0 -> 8 [label = "rate 3.1"];
//0 -> 5 [label = "rate 0.9"];
//1 -> 2 [label = "SUCCESS"];
//8 -> 2 [label = "FAIL"];
//}

// This operation takes in an AT state and:
//	1.	generates a new state id for the probabilistic state.
//	0.	For id in outgoing transitions of the specific AT state. 
//	2.		then it prints and transition from the AT state to the probabilistic state 
//			with a 'rate' label and lambda related to this BES.
//	3.		then it prints and transition form the probabilistic state to state 1 with
//			BES id as the label!.
//	4.		Collects ids of outgoing transitions of the specific AT state. 
//	5.		For every id:
//				select transtions with d1.newStatus == SUCCESS
//				count the nbr of transitions
//				for every Success transition
//					print edge from AT state to related new state with label "prob <prob/nbr>" 
//				select transtions with d1.newStatus == FAILED
//				count the nbr of transitions
//				For every Failed transition
//					print edge from AT state to related new state with label "prob <(1-prob)/nbr>" 


operation buildMAText(printDot:Boolean, printFullState:Boolean) : Sequence(Integer, Integer, String) {

/*	if ( UATV!Domain.allInstances().select(d|d.name == "lambda").size() == 0 or
		 UATV!Domain.allInstances().select(d|d.name == "prob").size() == 0  ) {
		throw "The BEs in the itermidiate automata does not have the required domains 'lambda' (rate) or 'prob' (probability) ";	 
	} */

	var IMA = IMA!InterimAutomaton.allInstances().first();
	var states = IMA!State.allInstances();
	var totNrOfStates = 0;
	var totNrOfTransitions = 0;
	var probStatesId = states.size() - 1;
	if ( printDot ) { probStatesId = states.size() * 2 - 1; }

	// Add values to BEs in attack-tree.
	// Values for Markov Automata. These are part of the IMA model.
	// MA specific values
	var rateDomain = UATV!Domain.allInstances().select(d|d.name == "lambda");
	var rateValues: Set(UATV!attributes) = Set{};
	if ( rateDomain.size() > 0 ) {
		rateValues = UATV!Domain.allInstances().select(d|d.name == "lambda").first().attributes;
	}
	
	var probDomain = UATV!Domain.allInstances().select(d|d.name == "prob");
	var probabilityValues:	Set(UATV!attributes)= Set{};
	if ( probDomain.size() > 0 ) {
		probabilityValues = UATV!Domain.allInstances().select(d|d.name == "prob").first().attributes;
	}

	var maStr:String = "";
	for (state in states) {
		if( state.outgoing.size() > 0 ){
			var stateStr = state.id.toString(); 
			if ( printFullState ) { stateStr = state.toString(false); }
		
			var beIDs = state.outgoing.collect( i|i.beId ).asSet();
			var beIDsCollaction = state.outgoing.collect( i|i.beId );
			for ( beID in beIDs ) { /* handel one outgoing Bes at a time */
				if( beID <> "SUCCESS" and beID <> "FAIL" ){
					var probability = probabilityValues.selectOne(a|a.node.id == beID );
					var rate = rateValues.selectOne(a|a.node.id == beID );
					
					if ( rate <> null ) {
						maStr = maStr.concat( toMarkoveTransitionString( printDot, stateStr, probStatesId++, beID, rate.value.value ) );
						totNrOfTransitions++;
					} else {
						maStr = maStr.concat( toMarkoveTransitionString( printDot, stateStr, probStatesId++, beID, 0 ) );
						totNrOfTransitions++;
					}
					
					if ( printDot ) { // TODO: cleanup duplicate code
						maStr = maStr.concat( toDecisionTansactionString( printDot, probStatesId, probStatesId++, beID ) );
					} else {
						maStr = maStr.concat( toDecisionTansactionString( printDot, probStatesId, probStatesId, beID ) );
					}
					totNrOfTransitions++;

					// Processed successfull distuptions
					var succesfullDisruptions = state.outgoing.select( i | i.beId == beID and i.newStatus == IMA!StatusType#SUCCESS ); 
					var probabilityDividerSuccesfullDisruptions = succesfullDisruptions.size();
					for ( disruption in succesfullDisruptions ){
						var targetStateStr = disruption.target.id.toString(); 
						if ( printFullState ) { targetStateStr = disruption.target.toString(false); }

						if ( probability <> null ) {
							maStr = maStr.concat( toProbabilityTransitionString( printDot, probStatesId, targetStateStr, beID, IMA!StatusType#SUCCESS, probability.value.value / probabilityDividerSuccesfullDisruptions) );
							totNrOfTransitions++;
						} else {
							maStr = maStr.concat( toProbabilityTransitionString( printDot, probStatesId, targetStateStr, beID, IMA!StatusType#SUCCESS, 1 / probabilityDividerSuccesfullDisruptions) );
							totNrOfTransitions++;
						}
					}
					// Processed failed distuptions
					var failedDisruptions = state.outgoing.select( i | i.beId == beID and i.newStatus == IMA!StatusType#FAILED ); 
					var probabilityDividerFailedDisruptions = failedDisruptions.size();
					for ( disruption in failedDisruptions ){
						if ( probability <> null ) {
							var targetStateStr = disruption.target.id.toString(); 
							if ( printFullState ) { targetStateStr = disruption.target.toString(false); }
							maStr = maStr.concat( toProbabilityTransitionString( printDot, probStatesId, targetStateStr, beID, IMA!StatusType#FAILED, ((1 - probability.value.value) / probabilityDividerFailedDisruptions) ) );
							totNrOfTransitions++;
						}
					}
				} else { /* end for !SUCCES and !FAIL */
					for ( disruptions in state.outgoing.select( i | i.beId == beID ) ){
						for ( disruption in disruptions ) {
							var targetStateStr = disruption.target.id.toString(); 
							if ( printFullState ) { targetStateStr = disruption.target.toString(false); }
							maStr = maStr.concat( toFinalTransitionString( printDot, stateStr, targetStateStr, beID ) );
							totNrOfTransitions++;
						}
					}
				}
			}
		}
	}
	return Sequence{ probStatesId + 1, totNrOfTransitions, maStr };
}

operation toMarkoveTransitionString(toDot:Boolean, stateID:String, nextProbabilityState:Integer, beID:String, value:Real) : String {
	if (toDot) {
		return ("\"" + stateID + "\"" + " -> " + nextProbabilityState + " [label = \"!" + beID + "\\n rate = " + value + "\", style=dashed]\n");
	} else {
		return ("("+ stateID + ", \"rate " + value + "\", " + nextProbabilityState + ")\n" );
	}
}

operation toDecisionTansactionString(toDot:Boolean, stateID:Integer, nextProbabilityState:Integer, beID:String) : String {
	if (toDot) {
		return ( (stateID + " -> " + nextProbabilityState + "\n") ).concat( nextProbabilityState + " [shape=point];\n" );
	} else {
		var label = beID; if ( ( beID <> "SUCCESS") and (beID <> "FAIL") ) { label = "BAS"; }
		return ( "(" + stateID + ", \"" + label + "\", 1)\n" );	/*TODO select target state */
	}
}

operation toProbabilityTransitionString(toDot:Boolean, dicisionStateID:Integer, nextState:String, beID:String, negation, value:Real) : String {
	var negationStr = "";
	if (negation == IMA!StatusType#FAILED) { negationStr = "Â¬";}
	if (toDot) {
		return (dicisionStateID + " -> " + "\"" + nextState + "\"" + " [label = \"" + negationStr + beID + "\\n prob = " + value.format("%.4s") + "\"]\n");
	} else {
		return ( "(" + dicisionStateID + ", \"prob " + value + "\", " + nextState + ")\n" );
	}
}

operation toFinalTransitionString(toDot:Boolean, stateID:String, nextState:String, beID:String) : String {
	if (toDot) {
		return ( ("\"" + stateID + "\"" + " -> " + "\"" + nextState + "\"" + " [label = \"" + beID + "\"]\n") );
	} else {
		var label = beID; if ( ( beID <> "SUCCESS") and (beID <> "FAIL") ) { label = "BAS"; }
		return ( "(" + stateID + ", \"" + label + "\", " + nextState + ")\n" );
	}
}
