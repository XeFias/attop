import "IntermediateStd.eol";

/******************************************************************************
*  Operations manipulate state
******************************************************************************/

/* A State is a consists out of two maps. Each map associates a node to a 
 * status value. The first map contains all the BEs. 
 * The second map contains all the Gates.
*/
operation constructInitialState(
			name:String, 
			nodes:Set(UATS!Node),
			goalGate:UATS!Node) 
		: IMA!State {

	var BEs		: Set(UATS!Node) = nodes.select(n|n.children.isEmpty()).asSet();
	var gates 	: Set(UATS!Node) = nodes.excludingAll(BEs);

	var s0 : IMA!State = new IMA!State;
	s0.name = name;
	s0.goalGateId = goalGate.id;
	for (be in BEs) {
		var id = be.id;
		id.~nodeRef = be; 
		s0.bes.put(id, IMA!StatusType#OPERATIONAL);
	}
	for (gate in gates) {
		var id : String = gate.id;
		id.~nodeRef = gate; 				// Maintain reference to node in 
											// the Attack Tree via ~nodeRef. 
		s0.gates.put(id, IMA!StatusType#OPERATIONAL);
	}
	return s0;
}

operation IMA!State createSuccesGoal()
		: IMA!State {
	var state : IMA!State = new IMA!State;
	state = self.copyState( "SUCCESS" );
	state.setAllStatuses( IMA!StatusType#DONTCARE );
	state.gates.put( self.goalGateId, IMA!StatusType#SUCCESS );
	return state;
}

operation IMA!State createFailGoal() 
		: IMA!State {
	var state : IMA!State = new IMA!State;
	state = self.copyState( "FAIL" );
	state.setAllStatuses( IMA!StatusType#DONTCARE );
	state.gates.put( self.goalGateId, IMA!StatusType#FAILED );
	return state;
}

operation IMA!State setAllStatuses( status ) {
	for (be in self.bes.keySet()) {
		self.bes.put(be, status);
	}
	for (gate in self.gates.keySet()) {
		self.gates.put(gate, status);
	}
}

operation status2Str(i) : String {
	switch (i) {
	 case IMA!StatusType#OPERATIONAL: return "O";
	 case IMA!StatusType#SUCCESS	: return "S";
	 case IMA!StatusType#FAILED		: return "F";
	 case IMA!StatusType#SAFE		: return "SF";
	 case IMA!StatusType#DONTCARE	: return "X";
	 default : throw "Error! intToStatus(" + i +") out of range.";
	}
}

operation IMA!State toString(withName:Boolean) : String {
	var r:String = "";
	r = r.concat("(");
	var BEs = self.bes;
	var stateStr = "";
	for ( be in BEs.keySet() ) {
		stateStr += ""+(be + ":" + status2Str(BEs.get(be)) + ",");
	}
	stateStr = stateStr.substring(0, stateStr.length()-1);
	stateStr += "||";
	for ( gate in self.gates.keySet() ) {
		stateStr += ""+(gate + ":" + status2Str(self.gates.get(gate)) + ",");
	}
	stateStr = stateStr.substring(0, stateStr.length()-1);
	if (withName) {
		r = r.concat(stateStr + ") = " + self.name);
	} else {
		r = r.concat(stateStr + ")");
	}

	return r;
}

operation IMA!State printState(withName:Boolean) {
	var t = self.toString(withName);
	t.println();
}

operation IMA!State copyState( newName:String )
		: IMA!State {
	var newState = self.copyState();
	newState.name = newName;
	return newState;
}

operation IMA!State copyState()
		: IMA!State {
	var s : IMA!State = new IMA!State;
	s.goalGateId = self.goalGateId;
	for ( key in self.bes.keySet() ){
		var value = self.bes.get(key);
		s.bes.put(key, value);
	}
	var gates : IMA!StringToStatusTypeMap;
	for ( key in self.gates.keySet() ){
		var value = self.gates.get(key);
		s.gates.put(key, value);
	}
	s.name = self.name;
	return s;
}

operation IMA!State getNodeStatus( node:UATS!Node ) {
	if (self.bes.containsKey( node.id ) ) {
		return self.bes.get( node.id );
	} else {
		return self.gates.get( node.id );
	}
}

operation IMA!State setNodeStatus( node:UATS!Node, value ) { // value is StatusType
	if (self.bes.containsKey( node.id ) ) {
		return self.bes.put( node.id,value );
	} else {
		return self.gates.put( node.id, value );
	}
}

operation IMA!State setDisruption( be:UATS!Node, change, target:IMA!State ) 
		: IMA!Disruption {
	var d1 : IMA!Disruption = new IMA!Disruption;
	d1.beId = be.id;
	d1.~be = be;
	d1.source = self;
	d1.target = target;
	d1.newStatus = change;
	return d1;
}


/**********************************EOF****************************************/