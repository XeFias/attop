import "stdfunctions.etl";

pre {
	System.out.println("IMA2Uppaal.etl:pre");
}

rule Base
	transform ima : IMA!InterimAutomaton
	to out : Uppaal!NSTA {
	
	System.out.println("ETL>Base IMA!InterimAutomation -> Uppaal!NSTA >>");
	out.int = new Uppaal!PredefinedType();
	out.int.name = "int";
	out.int.type = Uppaal!BuiltInType#INT;
	out.chan  = new Uppaal!PredefinedType();
	out.chan.name = "chan";
	out.chan.type = Uppaal!BuiltInType#CHAN;
	out.bool  = new Uppaal!PredefinedType();
	out.bool.name = "bool";
	out.bool.type = Uppaal!BuiltInType#BOOL;
	out.void  = new Uppaal!PredefinedType();
	out.void.name = "void";
	out.void.type = Uppaal!BuiltInType#VOID;
	out.clock  = new Uppaal!PredefinedType();
	out.clock.name = "clock";
	out.clock.type = Uppaal!BuiltInType#CLOCK;
	out.double  = new Uppaal!DoubleType();


	/*
	for (node : UATS!Node in ima.Nodes) {
		var converted = node.equivalent();
		if (converted <> null) {
			out.template.add(converted.get(0));
			out.systemDeclarations.declaration.add(converted.get(1));
			iList.template.add(converted.get(1).declaredTemplate);
		}
	}
	*/

	out.systemDeclarations = new Uppaal!SystemDeclarations();
	out.systemDeclarations.system = new Uppaal!System();
	var iList = new Uppaal!InstantiationList();
	out.systemDeclarations.system.instantiationList.add(iList);
	

	out.addTopLevel( ima );
	System.out.println("ETL>Base IMA!InterimAutomation -> Uppaal!NSTA << Done");
}
	
//Wasn't chaching this kind of operations important for performances? I didn't measure much, but it seems to have no effect..
@cached
operation getAllAttributes() : Sequence {
	return UATV!Attribute.allInstances();
}

operation Uppaal!NTA addTopLevel( ima : IMA!InterimAutomaton ) : Uppaal!Template {
	System.out.println("addTopLevel() >>");

	if ( UATV!Domain.allInstances().select(d|d.name == "cost").size() == 0 or
		 UATV!Domain.allInstances().select(d|d.name == "mintime").size() == 0 or
		 UATV!Domain.allInstances().select(d|d.name == "maxtime").size() == 0) {
		throw "The BEs in the itermidiate automata doe not have the required domains 'cost', 'mintime' or 'mintime'";	 
	} 

	var stateMap : Map(IMA!State,Uppaal!Location) = Map{};

	var tmpl : Uppaal!Template = new Uppaal!Template();
	tmpl.name = "Monolith";
	tmpl.declarations = new Uppaal!LocalDeclarations();
	// Initial state
	//var initLocation = tmpl.createLocation("Init").makeCommitted();
	//tmpl.init = initLocation;
	//var goalLocation = tmpl.createLocation("Goal");
	//var failLocation = tmpl.createLocation("Failed");



	// The clock
	var timeVar:Uppaal!Variable = tmpl.declareClock("x");

	var failsVar : Uppaal!Variable = createVariable("x_completed");
	failsVar.setInitialValue(0);
	var decl1 = createDataDeclaration(failsVar);
	decl1.typeDefinition.referredType = Uppaal!PredefinedType.allInstances().select(t | t.name = "int").first();
	tmpl.declarations.declaration.add(decl1);

	for (state : IMA!State in ima.states) {
		var skip = false;
		var	color = Uppaal!ColorKind#DEFAULT;
		var loc;
		var label = "";
		var isInit = false;
		switch( state.name ) {
			case "rootState" : {
				label = "Init";
				isInit = true;
			}
			case "SUCCESS" : {
				label = "Completed";
				color = Uppaal!ColorKind#GREEN;
			}
			case "FAIL" : {
				label = "FAIL";
				color = Uppaal!ColorKind#RED;
			}
			case "Final" : {
				skip = true;
			}
			default : {
				label = "at_" + state.id.toString();
			}
		}
		if ( not skip ) {
			loc = tmpl.createLocation( label );
			loc.setColor( color );
			if ( isInit ) { tmpl.init = loc; }
			loc.makeCommitted();
			("state = " + state.name + " loc " + loc ).println();
			stateMap.put( state, loc );
		}
	}

	var costs:	Set(UATV!attributes)	= UATV!Domain.allInstances().select(d|d.name == "cost").first().attributes;
	var minTs:	Set(UATV!attributes)	= UATV!Domain.allInstances().select(d|d.name == "mintime").first().attributes;
	var maxTs:	Set(UATV!attributes)	= UATV!Domain.allInstances().select(d|d.name == "maxtime").first().attributes;

	var costType:	UATV!Type	= UATV!Domain.allInstances().select(d|d.name == "cost").first().valueType;
	var minTType:	UATV!Type	= UATV!Domain.allInstances().select(d|d.name == "mintime").first().valueType;
	var maxTType:	UATV!Type	= UATV!Domain.allInstances().select(d|d.name == "maxtime").first().valueType;

	costType.println("costType = ");
	costs.get(0).value.println("costs = ");
	costs.get(0).value.type.println("costs type = ");
	
	var choiceState : Integer = 0; 

	// Add all transistions ?
	"State >> ".println();
	for (state : IMA!State in ima.states) {
		// Lookup state location 
		if( state.outgoing.size() > 0 ){
			var beIDs = state.outgoing.collect( i|i.beId ).asSet();
			var beIDsCollaction = state.outgoing.collect( i|i.beId );
			for ( beID in beIDs ) { /* handel one outgoing Bes at a time */
				if( beID <> "SUCCESS" and beID <> "FAIL" ){
					var cost = costs.selectOne(a|a.node.id == beID ).value.value.asInteger();
					var minT = minTs.selectOne(a|a.node.id == beID ).value.value.asInteger();
					var maxT = maxTs.selectOne(a|a.node.id == beID ).value.value.asInteger();
					// Make choice state
					var choice = tmpl.createLocation("c_" + choiceState );
					choiceState++;
					// Add invariant
					choice.setInvariant(createConjunction(
						timeVar.simpleComparison(maxT, Uppaal!CompareOperator#LESS_OR_EQUAL),
						createVariable("cost'").simpleComparison(maxT, Uppaal!CompareOperator#EQUAL)
					));
					// create edge from source to choice
					var srcLocation = stateMap.get(state);
					var toChoice = tmpl.createEdge(srcLocation, choice).resetClock(timeVar);
					// create guard from source to choice
					var incrementer = createAssignmentExpr(
							createVariable("cost").createReferringExpression(),
						    createLiteralExpression( cost )
					);
					incrementer.operator=Uppaal!AssignmentOperator#PLUS_EQUAL;					
					toChoice.addUpdate(incrementer);
					// Processed successfull distuptions
					"Success >>".println();
					var succesfullDisruptions = state.outgoing.select( i | i.beId == beID and i.newStatus == IMA!StatusType#SUCCESS ); 
					for ( disruption in succesfullDisruptions ){
						// create transition
						var targetLocation = stateMap.get(disruption.target);
						var toSuccess = tmpl.createEdge(choice, targetLocation);
						// create guard
						toSuccess.setGuard( timeVar.simpleComparison( minT, Uppaal!CompareOperator#GREATER_OR_EQUAL ) );
					}
					"Failed >>".println();
					// Processed failed distuptions
					var failedDisruptions = state.outgoing.select( i | i.beId == beID and i.newStatus == IMA!StatusType#FAILED ); 
					var probabilityDividerFailedDisruptions = failedDisruptions.size();
					for ( disruption in failedDisruptions ){
						// create transition
						var targetLocation = stateMap.get(disruption.target);
						var toFailure = tmpl.createEdge(choice, targetLocation);
					}
				} else { /* end for !SUCCES and !FAIL */
					for ( disruptions in state.outgoing.select( i | i.beId == beID ) ){
						for ( disruption in disruptions ) {
							//maStr = maStr.concat( toFinalTransitionString( printDot, state.id, disruption.target.id, beID ) );
						}
					}
				}
			}
		}
	}	
	
/*
	var disruptions = IMA!Disruption.allInstances();
	disruptions.size().println("IMA.disruptions.size() = ");

	"Disruption >> ".println();
	disruptions.size().println("ima.disruptions.size() = ");
	for (d : IMA!Disruption in disruptions ) {
		var converted = d.equivalent();
		if (converted <> null) {
			converted.type().println("equivalent type = ");
			converted.size().println("size = ");
			converted.println("converted = ");
		} else {
			if (converted == null) { "converted <> null".println(); }		
		}
	}
*/
	var decl = new Uppaal!TemplateDeclaration();
	decl.declaredTemplate = new Uppaal!RedefinedTemplate();
	decl.declaredTemplate.referredTemplate = tmpl;
	decl.declaredTemplate.name = "Process";
	
	self.template.add(tmpl);
	self.systemDeclarations.declaration.add(decl);
	self.systemDeclarations.system.instantiationList.at(0).template.add(decl.declaredTemplate);

	System.out.println("addTopLevel() <<");
	return tmpl;
}

/*
rule Disruption
	transform d : IMA!Disruption
	to ret : List {
	System.out.println("ETL>Disruption IMA!Disruption -> List >>");

	ret.add(1);
	
	System.out.println("ETL>Disruption IMA!Disruption -> List <<");
}

rule State
	transform d : IMA!State
	to ret : Uppaal!Location {
//	System.out.println("ETL>State IMA!State -> List >>");
	
	ret.name = d.id.toString();
	ret.locationTimeKind = Uppaal!LocationKind#NORMAL;
	ret.makeCommitted();
	//ret.add( createLocation( d.id.asString() ) );

//	System.out.println("ETL>State IMA!State -> List <<");
}
*/