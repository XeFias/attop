import "IMA2UppaalCommon.etl";

rule Base
	transform ima : IMA!InterimAutomaton
	to out : Uppaal!NSTA {
	
	out.initializePredefinedTypes();

	out.globalDeclarations = new Uppaal!GlobalDeclarations();
	out.declareClock("cost");

	var monolith = out.initializeTemplate( ima.states );
	
	var tmpl 	= monolith.get("tmpl");
	var stateMap= monolith.get("stateMap");
	var timeVar	= monolith.get("timeVar");

	var id2Index = out.addStates( tmpl, stateMap, ima.states, timeVar, globalWithCost );

	var rateTemplate = out.createBErateTemplate( id2Index.keySet().size(), globalWithCost, true, true );
	var rateWithoutCostRateTemplate = out.createBErateTemplate( id2Index.keySet().size(), globalWithCost, false, false );

	out.addAllBErateProcesses( rateTemplate, rateWithoutCostRateTemplate, globalWithCost, id2Index );

}

operation Uppaal!NTA addStates(	tmpl	: Uppaal!Template, 
								stateMap: Map(IMA!State,Uppaal!Location),
								states	: Set(IMA!State),
								timeVar	: Uppaal!Variable,
								globalWithCost : Boolean  ) : Map(String, Integer) {
	var index = 0;
	var choiceState : Integer = 0; 
	var IFAILState	: Integer = 0; 
	var uniqueId	: Integer = 0;
	var id2Index	: Map(String, Integer) = Map{};

	var disruptions:Set(String) = IMA!Disruption.allInstances().collect( d | d.beId ).asSet();
	for ( beID in disruptions ) { id2Index.put(beID, index); index++;	}

	// Add values to BEs in attack-tree.
	// Values for Markov Automata. These are part of the IMA model.
	// MA specific values
	var rateDomain = UATV!Domain.allInstances().select(d|d.name == "lambda");
	var rateValues: Set(UATV!attributes) = Set{};
	if ( rateDomain.size() > 0 ) {
		rateValues = UATV!Domain.allInstances().select(d|d.name == "lambda").first().attributes;
	}
	
	var probDomain = UATV!Domain.allInstances().select(d|d.name == "prob");
	var probabilityValues:	Set(UATV!attributes)= Set{};
	if ( probDomain.size() > 0 ) {
		probabilityValues = UATV!Domain.allInstances().select(d|d.name == "prob").first().attributes;
	}
	
	// Add all transistions ?
	for (state : IMA!State in states) {
		// Lookup state location 
		if( state.outgoing.size() > 0 and state.name <> "SUCCESS" and state.name <> "FAIL"){
			var id2IndexOutgoing : Map(String, Integer) = Map{};
			var beIDs 			= state.outgoing.collect( i|i.beId ).asSet();
			var beIDsCollaction = state.outgoing.collect( i|i.beId );
			var IFAILBEs = countIFAIL( rateValues, beIDsCollaction );

			for ( beID in beIDs ) { id2IndexOutgoing.put( beID, id2Index.get( beID ) ); }
			
			// Filter beIDs with BE rate <> 0.
			// var iFailBEs:Set(BE) = Set{}. Collect all IFAIL BEs.
			if ( IFAILBEs.size() <= 0 ) {
				// When IFAIL-set is empty add chain if committed states to start every BE.
				// ending in a split where there exist and outgoing transition for every BE.
				
				var exitLocations = addRateTransitions( tmpl, id2IndexOutgoing, stateMap, uniqueId++, state );
				
				uniqueId++;
				for ( beID in exitLocations.keySet() ) { /* handel one outgoing Bes at a time */
					var location = exitLocations.get(beID);
					choiceState = addProbabilityBasedBEWithRate_New( tmpl, stateMap, timeVar, state, beID, location, choiceState);
				}
				
			} else { 
				// When IFAIL-set is NOT empty add probabilistic transation where 
				// the probability is divided equally between all outgoing IFAIL transitions.
				var stateLocation = stateMap.get(state);
				var choice = tmpl.createChanceNode("Choosing_" + choiceState);
				choiceState++;
				tmpl.createEdge(stateLocation, choice);

				for ( BeID in IFAILBEs ){
					var cost:Integer = 0 ;
					// create node and transitions
					var IFAILLocation = tmpl.createLocation("IFAIL_" + BeID + "_" + IFAILState ).makeCommitted();
					IFAILState++; 
					var toBE = tmpl.createChanceEdge(choice, IFAILLocation, 1);
					// Add fixed cost.
					var activationCost = getCost( BeID, UATV!CostType#ON_ACTIVATION ).asInteger();
					if ( activationCost <> -1 ) { cost = activationCost; } 		
					if ( globalWithCost ) {
						toBE.addUpdate(
							createAssignmentExpr(
								createVariable("cost").createReferringExpression(),
								createSum(	createVariable("cost").createReferringExpression(),
											createLiteralExpression( cost.asString() ) ) ) );
					}
					choiceState = addProbabilityBasedBEWithRate_New( tmpl, stateMap, timeVar, state, BeID, IFAILLocation, choiceState );
				}
			}
		}
	}	
	
	return id2Index;
}

operation addProbabilityBasedBE(tmpl	: Uppaal!Template, 
								stateMap: Map(IMA!State,Uppaal!Location),
								timeVar	: Uppaal!Variable,
								state	: IMA!State,
								beID	: String,
								choiceState : Integer,
								globalWithCost : Boolean  ) {
	// Select between rate or time delay information	
	return addProbabilityBasedBEWithRate( tmpl, stateMap, timeVar, state, beID, choiceState, globalWithCost );
}

operation addProbabilityBasedBEWithRate_New(tmpl	: Uppaal!Template, 
										stateMap: Map(IMA!State,Uppaal!Location),
										timeVar	: Uppaal!Variable,
										state	: IMA!State,
										beID	: String,
										location: Uppaal!Location,
										choiceState : Integer) : Integer{
	var activationCost = getCost( beID, UATV!CostType#ON_ACTIVATION ).asInteger();
	var activeCost = getCost( beID, UATV!CostType#WHILE_ACTIVE ).asInteger();

	var srcLocation = location;
	var choice = tmpl.createChanceNode("Choosing_" + choiceState);
	choiceState++;

	/*
	var delayLocation = tmpl.createExpLocation("Active_" + choiceState);
	delayLocation.addComment( beID );
	choiceState++;
	*/

	var prob : Real = getProbability( beID );
	if ( prob == -1 ) { // No probability has been set. Basic Component Failure (BCF). 
		prob = 1;
	}

	var weight1 : Integer = (prob * 32768.0).round();
	var weight2 : Integer = 32768 - weight1;
	if (weight1 == 32768 and prob < 1.0) {
		System.err.println("Warning: BE" + beID + " has very high probability rounding off to 1, results will be inaccurate.");
		weight1 = 32767;
		weight2 = 1;
	} else if (prob == 1.0) {
		weight1 = 1;
	} else if (weight1 == 0 and prob > 0.0) {
		System.err.println("Warning: BE" + beID + " has very low probability rounding off to 0, results will be inaccurate.");
		weight1 = 1;
		weight2 = 32767;
	} else if (prob == 0.0) {
		weight2 = 1;
	}

	var toChoice = tmpl.createEdge( srcLocation, choice );
	// Processed successfull distuptions
	var succesfullDisruptions = state.outgoing.select( i | i.beId == beID and i.newStatus == IMA!StatusType#SUCCESS ); 
	for ( disruption in succesfullDisruptions ){
		// create transition
		var targetLocation = stateMap.get(disruption.target);
		var toSuccess = tmpl.createChanceEdge(choice, targetLocation, weight1);
		// TODO: add global damage update here.
		toSuccess.addComment("Success");
		// Note: nondeterminism (Multiple Success transitions) is not yet supported
	}
	
	// Processed failed distuptions
	var failedDisruptions = state.outgoing.select( i | i.beId == beID and i.newStatus == IMA!StatusType#FAILED ); 
	var probabilityDividerFailedDisruptions = failedDisruptions.size();
	for ( disruption in failedDisruptions ){
		// create transition
		var targetLocation = stateMap.get(disruption.target);
		var toFailure = tmpl.createChanceEdge(choice, targetLocation, weight2);
		toFailure.addComment("Fail");
		// Note: nondeterminism (Multiple Fail transitions) is not yet supported
	}

	return choiceState;
}



operation addProbabilityBasedBEWithRate(tmpl	: Uppaal!Template, 
										stateMap: Map(IMA!State,Uppaal!Location),
										timeVar	: Uppaal!Variable,
										state	: IMA!State,
										beID	: String,
										choiceState : Integer,
										globalWithCost : Boolean ) {
	var activationCost = getCost( beID, UATV!CostType#ON_ACTIVATION ).asInteger();
	var activeCost = getCost( beID, UATV!CostType#WHILE_ACTIVE ).asInteger();

	var srcLocation = stateMap.get(state);
	var choice = tmpl.createChanceNode("Choosing_" + choiceState);
	choiceState++;

	var delayLocation = tmpl.createExpLocation("Active_" + choiceState);
	delayLocation.addComment( beID );
	choiceState++;

	if ( globalWithCost ) {
		// cost accumulator
		delayLocation.setInvariant( createVariable("cost'").simpleComparison(activeCost, Uppaal!CompareOperator#EQUAL) );
	}
	var rate = getRate( beID );
	if ( rate == -1 ) { // No rate has been set.
		rate = 0;
	}
	delayLocation.exitRate = createLiteralExpression( rate );

	var prob : Real = getProbability( beID );
	if ( prob == -1 ) { // No probability has been set. 
		prob = 1;
	}

	var weight1 : Integer = (prob * 32768.0).round();
	var weight2 : Integer = 32768 - weight1;
	if (weight1 == 32768 and prob < 1.0) {
		System.err.println("Warning: BE" + beID + " has very high probability rounding off to 1, results will be inaccurate.");
		weight1 = 32767;
		weight2 = 1;
	} else if (prob == 1.0) {
		weight1 = 1;
	} else if (weight1 == 0 and prob > 0.0) {
		System.err.println("Warning: BE" + beID + " has very low probability rounding off to 0, results will be inaccurate.");
		weight1 = 1;
		weight2 = 32767;
	} else if (prob == 0.0) {
		weight2 = 1;
	}

	var fromSource = tmpl.createEdge(srcLocation, delayLocation);	
	fromSource = fromSource.resetClock(timeVar); // x := 0
	fromSource.addComment("t_" + beID );

	if ( globalWithCost ) {
		fromSource.addUpdate(
			createAssignmentExpr(
				createVariable("cost").createReferringExpression(),
				createSum(	createVariable("cost").createReferringExpression(),
							createLiteralExpression( activationCost ) ) ) );
	}
	var toChoice = tmpl.createEdge( delayLocation, choice );
	// Processed successfull distuptions
	var succesfullDisruptions = state.outgoing.select( i | i.beId == beID and i.newStatus == IMA!StatusType#SUCCESS ); 
	for ( disruption in succesfullDisruptions ){
		// create transition
		var targetLocation = stateMap.get(disruption.target);
		var toSuccess = tmpl.createChanceEdge(choice, targetLocation, weight1);
		toSuccess.addComment("Success");
		// Note: nondeterminism (Multiple Success transitions) is not yet supported
	}
	
	// Processed failed distuptions
	var failedDisruptions = state.outgoing.select( i | i.beId == beID and i.newStatus == IMA!StatusType#FAILED ); 
	var probabilityDividerFailedDisruptions = failedDisruptions.size();
	for ( disruption in failedDisruptions ){
		// create transition
		var targetLocation = stateMap.get(disruption.target);
		var toFailure = tmpl.createChanceEdge(choice, targetLocation, weight2);
		toFailure.addComment("Fail");
		// Note: nondeterminism (Multiple Fail transitions) is not yet supported
	}

	return choiceState;
}


operation addProbabilityBasedBEWithoutRate(	tmpl	: Uppaal!Template, 
											stateMap: Map(IMA!State,Uppaal!Location),
											timeVar	: Uppaal!Variable,
											state	: IMA!State,
											beID	: String,
											choiceState : Integer,
											globalWithCost : Boolean  ) {
	var minT = getTime( beID, UATV!TimeType#MINIMUM ).asInteger();
	var maxT = getTime( beID, UATV!TimeType#MAXIMUM ).asInteger();

	var activationCost = getCost( beID, UATV!CostType#ON_ACTIVATION ).asInteger();
	var activeCost = getCost( beID, UATV!CostType#WHILE_ACTIVE ).asInteger();

	var srcLocation = stateMap.get(state);
	var choice = tmpl.createChanceNode("Choosing_" + choiceState);
	choiceState++;

	var fromSource = tmpl.createEdge(srcLocation, choice);	
	fromSource = fromSource.resetClock(timeVar);
	fromSource.addComment("t_" + beID );
	
	var prob : Real = getProbability( beID);
	var weight1 : Integer = (prob * 32768.0).round();
	var weight2 : Integer = 32768 - weight1;
	if (weight1 == 32768 and prob < 1.0) {
		System.err.println("Warning: BE" + beID + " has very high probability rounding off to 1, results will be inaccurate.");
		weight1 = 32767;
		weight2 = 1;
	} else if (prob == 1.0) {
		weight1 = 1;
	} else if (weight1 == 0 and prob > 0.0) {
		System.err.println("Warning: BE" + beID + " has very low probability rounding off to 0, results will be inaccurate.");
		weight1 = 1;
		weight2 = 32767;
	} else if (prob == 0.0) {
		weight2 = 1;
	}

	// Processed successfull distuptions
	var succesfullDisruptions = state.outgoing.select( i | i.beId == beID and i.newStatus == IMA!StatusType#SUCCESS ); 
	for ( disruption in succesfullDisruptions ){
		// create transition
		var targetLocation = stateMap.get(disruption.target);
		var delayLocation = tmpl.createExpLocation("Active_" + choiceState);
		delayLocation.addComment( "¬"+beID );
		choiceState++;

		if ( globalWithCost ){
			delayLocation.setInvariant(	createVariable("cost'").simpleComparison(activeCost, Uppaal!CompareOperator#EQUAL) );
		} else {
			//delayLocation.setInvariant(timeVar.simpleComparison( maxT, Uppaal!CompareOperator#LESS_OR_EQUAL ) ); 
		}
		
		tmpl.createChanceEdge(choice, delayLocation, weight1);
		var toSuccess = tmpl.createEdge(delayLocation, targetLocation);
		// add guard if no delay
		toSuccess.setGuard( timeVar.simpleComparison( minT, Uppaal!CompareOperator#GREATER_OR_EQUAL ) );
		toSuccess.addComment("Success");
	
		if ( globalWithCost ){
			fromSource.addUpdate(
				createAssignmentExpr(
					createVariable("cost").createReferringExpression(),
					createSum(	createVariable("cost").createReferringExpression(),
								createLiteralExpression( activationCost ) ) ) );
		}
	}
	
	// Processed failed distuptions
	var failedDisruptions = state.outgoing.select( i | i.beId == beID and i.newStatus == IMA!StatusType#FAILED ); 
	var probabilityDividerFailedDisruptions = failedDisruptions.size();
	for ( disruption in failedDisruptions ){
		// create transition
		var targetLocation = stateMap.get(disruption.target);
		//var toFailure = tmpl.createEdge(choice, targetLocation);
		var toFailure = tmpl.createChanceEdge(choice, targetLocation, weight2);
		toFailure.addComment("Fail");
	}

	return choiceState;
}


// Utilities
// Returns an associated completion probability, or -1 if there is no such attribute.
@cached
operation getProbability( id : String ) : Real {
		var attributes = UATV!Attribute.allInstances().select(n | n.node.id == id);
		var delayAttrs = attributes.select(a | a.eContainer.purpose.isKindOf(UATV!ProbabilityPurpose));
		var expAttrs = delayAttrs.select(a | a.eContainer.purpose.probType = UATV!ProbabilityType#COMPLETION);
		if (expAttrs.isEmpty())
			return -1;
		return expAttrs.first().value.value.asReal();
}

// Returns whether the node has any attributes with time purpose.
@cached
operation hasTimeDelay( id : String ) : Boolean {
		var attributes = UATV!Attribute.allInstances().select(n | n.node.id == id);
		var delayAttrs = attributes.select(a | a.eContainer.purpose.isKindOf(UATV!TimePurpose));
		return not delayAttrs.isEmpty();
}

// Returns an associated completion delay, or -1 if there is no such attribute.
@cached
operation getRate( id : String ) : Real {
	var attributes = UATV!Attribute.allInstances().select(n | n.node.id == id);
	var delayAttrs = attributes.select(a | a.eContainer.purpose.isKindOf(UATV!TimePurpose));
	var expAttrs = delayAttrs.select(a | a.eContainer.purpose.timeType = UATV!TimeType#EXPONENTIAL);
	if (expAttrs.isEmpty())
		return -1;
	return expAttrs.first().value.value.asReal();
}

// TODO: remove duplicate code 
operation countIFAIL( rateValues, disruptions ) : Set(String) {
	var count:Integer = 0;
	var beIDs:Set(String) = Set{};
	for ( beID in disruptions ) { /* handel one outgoing Bes at a time */
		if( beID <> "SUCCESS" and beID <> "FAIL" ){
			//var probability = probabilityValues.selectOne(a|a.node.id == beID );
			var rate = rateValues.selectOne(a|a.node.id == beID );
			if ( rate == null and beIDs.excludes( beID ) ) {
				beIDs.add( beID );
				count++;
			}
		}
	}
	return beIDs;
}

operation addRateTransitions(	tmpl	: Uppaal!Template, 
								id2Index: Map(String, Integer), 				
								stateMap: Map(IMA!State,Uppaal!Location),
								uniqueId: Integer,  
								state	: IMA!State) : Map(String,Uppaal!Location) {
	var locationMap:Map(String,Uppaal!Location) = Map{};
	
	var srcLocation = stateMap.get(state);

	var resetLocation = tmpl.createLocation("reset_actBE_" + uniqueId).makeCommitted();
	var resetEdge = tmpl.createEdge(srcLocation, resetLocation);
	// TODO: Add output to activationEdge
	var resetBEsStr = "resetBEs";
	var resetBEsVar = createVariable(resetBEsStr).createReferringExpression();
	resetEdge.setSync(resetBEsVar, true);

	var prevLocation = resetLocation;
	// Build activation chain.	
	for ( beID in id2Index.keySet() ){
		if( beID <> "SUCCESS" and beID <> "FAIL" ){
			var activeLocation = tmpl.createLocation("activate_actBE_" + uniqueId + beID).makeCommitted();
			var activationEdge = tmpl.createEdge(prevLocation, activeLocation);
			// TODO: Add output to activationEdge
			var rateStartStr = "rateStart";
			var rateStartBEsVar = createVariable(rateStartStr).createReferringExpression().makeArrayExpression( id2Index.get( beID ) );
			activationEdge.setSync(rateStartBEsVar, true);
			prevLocation = activeLocation;
		}
	}
	
	// remove commit for last state in the chain.
	prevLocation.makeNormal();

	// Build rate fork.	
	for ( beID in id2Index.keySet() ){
		if( beID <> "SUCCESS" and beID <> "FAIL" ){
			var exitLocation = tmpl.createLocation("exit_BE_" + uniqueId + beID).makeCommitted();
			locationMap.put( beID, exitLocation );
			var exitEdge = tmpl.createEdge(prevLocation, exitLocation);
			var rateCompleteStr = "rateComplete";
			var rateCompleteBEsVar = createVariable(rateCompleteStr).createReferringExpression().makeArrayExpression( id2Index.get( beID ) );
			exitEdge.setSync(rateCompleteBEsVar, false);
		}
	}
	// return a Map from BE to the location which the state at which the  
	// rate processes have selected a winner.
	return locationMap;
}

