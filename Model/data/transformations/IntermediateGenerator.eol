import "IntermediateIterator.eol";
import "IntermediateState.eol";
import "IntermediateStateMap.eol";

operation generateIntermediateAutomata( 
			attackTree:UATS!AttackTree, 
			rootNode:UATS!Node ) 
		: Sequence(IMA!State) {
	// Assotiate Gates to graph height (from bottom to top) and depth (from top to bottom)  
	var nodes	: Set(UATS!Node) = attackTree.Nodes;
	var BEs		: Set(UATS!Node) = nodes.select(n|n.children.isEmpty()).asSet();
	var bottomUp: Sequence(UATS!Node) = fromLevelMapToSequence(calculateHeightOfGates(BEs));
	var topDown	: Sequence(UATS!Node) = fromLevelMapToSequence(calculateDepthOfGates(rootNode));
	for ( be in BEs ) { topDown.add(be); } // Add BEs to the tail of the topDown iterator.
	
	var gates 			= nodes.excludingAll(BEs);
	var bottomUpIterator= createIterator(bottomUp);
	var topDownIterator	= createIterator(topDown);
	var gStateMap 		= createStateMap();
	var rootState 		= constructInitialState("rootState", nodes, rootNode);
	var successGoalState= rootState.createSuccesGoal();
	var failGoalState	= rootState.createFailGoal();
	var finalStates		= Map{	IMA!GoalState#SUCCESS	= successGoalState,
								IMA!GoalState#FAILED	= failGoalState};
	gStateMap.put(rootState);
	gStateMap.put(successGoalState);
	gStateMap.put(failGoalState);

	// Mark the gates in the attack-tree with a Map describing there reachability.
	markGatesReachableFromBAS( bottomUpIterator.copyIterator(), BEs );	 

	for ( nextStatus in Sequence{ IMA!StatusType#SUCCESS, IMA!StatusType#FAILED } ) {
		for ( be in rootState.bes.keySet() ) {
			var nextStatesBe = recur_buildIMA(	gStateMap, 
												bottomUpIterator, 
												topDownIterator,
												finalStates,
												rootNode, 
												rootState,
												be.~nodeRef, 
												nextStatus );
			for ( state in nextStatesBe ) {
				rootState.setDisruption( be.~nodeRef, nextStatus, state );
				
				// TODO: Not nice duplicate code. Move to recur_buildIMA ?				
				var statusType = state.getNodeStatus( rootNode );
				if ( statusType <> IMA!StatusType#OPERATIONAL ) {
					switch (statusType) {
						case IMA!StatusType#SUCCESS	:{ state.setDisruption( null, IMA!StatusType#SUCCESS, finalStates.get("success") ); }
						case IMA!StatusType#FAILED	:{ state.setDisruption( null, IMA!StatusType#FAILED, finalStates.get("failed") ); }
						case IMA!StatusType#SAFE	:{ state.setDisruption( null, IMA!StatusType#FAILED, finalStates.get("failed") ); }
						case IMA!StatusType#DONTCARE:{ throw ( "rootNode unexpectedly is DONTCARE" ); }
						default : throw (rootState.children.println("unknown StatusType " + statusType));
					}
				}

			}
		}
	}
	// TODO: find all success and fail goals.
	return Sequence{ rootState, successGoalState, failGoalState };
}

operation fromLevelMapToSequence( 
			levelMap:Map(UATS!Node,Sequence) ) 
: Sequence(UATS!Node) {
	var nbrOfLevels =  levelMap.values().max();
	var inversMap = inverseMapRelation(levelMap);
	var order = Sequence {};
	for (level in 1.to(nbrOfLevels)){
		order += inversMap.get(level);
	}
	return order;
}

// TODO: rename
operation recur_buildIMA(	gStateMap:Map(Integer, Sequence(IMA!State)), 
							bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
							topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)),
							finalStates:Map(Any,IMA!State),/* Any is StatusType */
							rootNode:UATS!Node, 
							prevState:IMA!State, 
							be:UATS!Node, 
							nextStatus ) 
: Set(IMA!State) {

	var newState = prevState.copyState( "Generated" ); // TODO: maybe use state name as hash?
	// Set BE in state to newStatus
	newState.setNodeStatus( be, nextStatus );

	// Calculate the new statuses of the gates in this State
	var newStates = newState.calculateGateStatusesInState( bottomUp, prevState, be ); 
	var missingStates:Set(IMA!State) = Set{};
	var existingStates:Set(IMA!State) = Set{};
	var doubleStates:Set(IMA!State) = Set{};

	for ( newState in newStates ) {
		// Propogate SAFE Statuses.
		newState.setSafeStatuses( bottomUp.copyIterator(), be );
		// Propogate DONTCARE Statuses.
		newState.propogateDontCareStatuses( topDown.copyIterator() );

		// Check if this state already exists 
		var exists:Sequence(Boolean,IMA!State) = gStateMap.get( newState );
		
		if ( exists.first() == false ) {
			gStateMap.put( newState );
			// Add nonexisting state
			missingStates.add( newState );
		} else {
			// remember the existing state.
			existingStates.add( exists.second() );
			// forget/remove the doubles
			doubleStates.add( newState );
		}
	}

	for (state in doubleStates){
		delete state; // Make sure the double states are deleted from the model !!!
	}

	// The caller will create transitions to the state which are returned. This
	// must include the excisting state which are reached. 
	var targetStates = missingStates.includingAll( existingStates );
		
	// Recursively process new states to create the monolithic automata.
	for ( nextState in missingStates ) {
		nextState.recur2_buildIMA( gStateMap, bottomUp, topDown, finalStates, rootNode);
	}

	return targetStates;
}

operation IMA!State recur2_buildIMA(	
							gStateMap:Map(Integer, Sequence(IMA!State)),
							bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
							topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)),
							finalStates:Map(Any,IMA!State), /* Any is StatusType */
							rootNode:UATS!Node ) {

	// Get remaining BEs which are still OPERATIONAL.
	for ( be in self.getOperationalBEs() ) {
		// Process state when BE SUCCEEDS or FAILS.
		for ( nextStatus in Sequence{ IMA!StatusType#SUCCESS, IMA!StatusType#FAILED } ) {
			var nextStatesBe = recur_buildIMA(	gStateMap, 
												bottomUp,
												topDown,
												finalStates,
												rootNode,
												self,
												be.~nodeRef,
												nextStatus );
			for ( state in nextStatesBe ) { // Create an edge to the new states with BE action as a label.  
				self.setDisruption( be.~nodeRef, nextStatus, state );

				// TODO: Not nice duplicate code. Move to recur_buildIMA ?				
				var statusType = state.getNodeStatus( rootNode );
				if ( statusType <> IMA!StatusType#OPERATIONAL ) {
					// ? Does this link already exist.
					switch ( statusType ) {
						case IMA!StatusType#SUCCESS	:{ state.setDisruption( null, IMA!StatusType#SUCCESS, finalStates.get(IMA!GoalState#SUCCESS) ); }
						case IMA!StatusType#FAILED	:{ state.setDisruption( null, IMA!StatusType#FAILED, finalStates.get(IMA!GoalState#FAILED) ); }
						case IMA!StatusType#SAFE	:{ state.setDisruption( null, IMA!StatusType#FAILED, finalStates.get(IMA!GoalState#FAILED) ); }
						case IMA!StatusType#DONTCARE:{ throw ( "rootNode unexpectedly is DONTCARE" ); }
						default : throw (self.children.println("unknown StatusType " + statusType));
					}
				}
			}
		}
	}
}

operation IMA!State calculateGateStatusesInState( 
						bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)),
						prevState:IMA!State,
						be:UATS!Node ) 
						: Set(IMA!State) {
	var DonePackets = Set{};
	var TodoPackets = Set{};
	var packetOfWork = Sequence { self, bottomUp.copyIterator(), be };
	TodoPackets.add( packetOfWork );
	
	while ( TodoPackets.size() > 0 ) {
		var work =  TodoPackets.random();
		TodoPackets.remove( work );
		// processPacketOfWork() can generate new packets of work due to raceconditions.
		var newPacketsOfWork = work.first().processPacketOfWork( work.second(), prevState, work.third() );
		DonePackets.add(work.first());
		TodoPackets.addAll( newPacketsOfWork );
	}
	return DonePackets;
}

operation IMA!State processPacketOfWork(
	bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)),
	prevState:IMA!State, 
	be		:UATS!Node )
: Set(Sequence) { // Set { Sequence { newState, bottomUp.copyIterator(), be } };
	var r:Set(Sequence(Any)) = Set{};

	while ( bottomUp.hasNext() ) {
		var gate = bottomUp.next();
		var newStatuses = gate.calculateStatusInState( self, prevState, be );
		if ( newStatuses.size() == 1 ) {
			var status = newStatuses.first();
			self.setNodeStatus(gate, status);
		} else if ( newStatuses.size() > 1 ) {
			var i = 0;
			for ( newStatus in newStatuses ) {
				if (i == 0) {
					self.setNodeStatus(gate, newStatus); 
				} else {
					var newNextState = self.copyState( "R" );
					var bottomUpCopy = bottomUp.copyIterator();
					newNextState.setNodeStatus(gate, newStatus);
					r.add( Sequence{ newNextState, bottomUpCopy, be } );
				}
				i++;
			}
		} else {
			throw ("When calculating the status of a Gate " + gate.id + " returned no status.");
		}
	}
	return r;
}

          // Gate.
operation UATS!Node calculateStatusInState( state:IMA!State, prevState:IMA!State, be:UATS!Node )
: Set(Any) /*IMA!StatusType*/ {
	var r:Set() = Set{};
	switch (self.connector.type().name) {
		case "AND"	:{ r.add(state.calculateStatusOfAND(self)); }
		case "OR"	:{ r.add(state.calculateStatusOfOR(self)); }	
		case "SAND"	:{ r.addAll(state.calculateStatusOfSAND(self, prevState, be)); }
		default : throw (self.children.println("process UNKNOWN Gate!____" 
						+ self.connector.gate.id));
	}
	return r;
}

operation IMA!State calculateStatusOfAND( gate:UATS!Node )
: Any /*IMA!StatusType*/ {
	if ( gate.children.forAll( child |  self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		// If all childeren are SUCCESS return SUCCESS,
		return IMA!StatusType#SUCCESS;
	} else if ( gate.children.exists( child | 
					self.getNodeStatus(child) == IMA!StatusType#FAILED )) {
		// If any is FAILED return FAILED,
		return IMA!StatusType#FAILED;
	} else if ( gate.children.exists( child | 
					self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
		// If any is FAILED return FAILED,
		return IMA!StatusType#SAFE;
	} else {
		// Keep gate Operational.
		return IMA!StatusType#OPERATIONAL;
	}
	// If DONTCARE ?? error because unexpected.
}

operation IMA!State calculateStatusOfOR( gate:UATS!Node )
: Any /*IMA!StatusType*/ {
	if ( gate.children.exists(
			child | self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		// If any child is SUCCESS return SUCCESS,
		return IMA!StatusType#SUCCESS;
	} else if ( gate.children.forAll(
			child | self.getNodeStatus(child) == IMA!StatusType#FAILED
					or self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
		// If all are FAILED of SAFE return FAILED,
		return IMA!StatusType#FAILED;
	} else {
		// Keep gate Operational.
		return IMA!StatusType#OPERATIONAL;
	}
}

// TODO: possible race conditions implemented in DFTCalc and STORM?
operation IMA!State calculateStatusOfSAND( gate:UATS!Node, prevState:IMA!State, be:UATS!Node )
: Set(Any) /* Set(IMA!StatusType) */ {
	var statuses = Set{};
	//	gate.~beToChildrenFinal: describes via which children of the gate BE can
	//  reach the gate. It only mentions BEs which can reach the gate via multiple
	//  children resulting in race conditions. This information is only of importance
	//  to SAND and SOR gates.
	// 
	
	var bes = gate.~beToChildrenFinal.keySet();
	if ( bes.includes( be ) and (prevState <> null) ) { // TODO prevent passing null.
		// Because 'be' can reach this gate via multiple children activation of
		// this 'be' could possibly generate multiple outcomes
		for ( childA in gate.~beToChildrenFinal.get( be ) ) {
			// 1. Copy children from previous state
			var tempState = self.copyState("tempState");
			// 2. Reset children which participate in a race condition to the previous status, except 'childA'.  
			for ( childB in gate.~beToChildrenFinal.get( be ) ) {
				if ( childB <> childA ) {
					var prevStatus = prevState.getNodeStatus( childB );
					tempState.setNodeStatus( childB, prevStatus );
				}
			}
			// 3. Calculate the new state by check condition of children (forAll( )).
			// 4. Add result to return Set{}.
			var r2 = tempState.calculatedStatusOfSAND( gate );
			statuses.add( r2 );

			// remove newly created temperary status.			
			delete tempState;			
		}
	} else {
		// No race-condition. 
		statuses.add( self.calculatedStatusOfSAND( gate ) );
	}
	return statuses;
}

operation IMA!State calculatedStatusOfSAND( gate:UATS!Node ) 
:Any /* Set(IMA!StatusType) */ {
	if ( self.isActivatedFromLeft( gate.children ) == false ) {
		return IMA!StatusType#SAFE;
	}

	if ( gate.children.forAll( child |  self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		return IMA!StatusType#SUCCESS;
	} else if ( gate.children.exists( child | 
					self.getNodeStatus(child) == IMA!StatusType#FAILED )) {
		// If any is FAILED return FAILED,
		return IMA!StatusType#FAILED;
	}

	return IMA!StatusType#OPERATIONAL;
}

operation IMA!State calculateStatusOfSOR( gate:UATS!Node )
: Any /*IMA!StatusType*/ {
	throw("TODO");
	if ( self.isActivatedFromLeft( gate.children ) == false ) {
		return IMA!StatusType#SAFE;
	}

	if ( gate.children.exists(
			child | self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		// If any child is SUCCESS return SUCCESS,
		return IMA!StatusType#SUCCESS;
	} else if ( gate.children.forAll(
			child | self.getNodeStatus(child) == IMA!StatusType#FAILED
					or self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
		// If all are FAILED of SAFE return FAILED,
		return IMA!StatusType#FAILED;
	}

	return IMA!StatusType#OPERATIONAL;
}

operation IMA!State isActivatedFromLeft( children:OrderedSet(UATS!Node) ) : Boolean {  
	var next = 0;
	while ( (next <= children.size() - 1 ) // Search first child which is not yet activated 
			and ( self.getNodeStatus( children.at( next ) ) <> IMA!StatusType#OPERATIONAL ) ) {
		next++;
	}
	if ( next > children.size() - 1 ) { // If all children are activated order is correct.
		return true;
	} else { 							// Else some are stil not activated.
										// From here all must be unactivated
		while ( ( next <= children.size() - 1 ) 
				and( self.getNodeStatus( children.at( next ) ) == IMA!StatusType#OPERATIONAL ) ) {
			next++;
		}
		if ( next > children.size() - 1 ) { // All remaining children remain unactivated.
			return true;
		} else { 							// Detected yet an activated child after an
			return false;					// unactivated child.
		}
	}
}

operation IMA!State getOperationalBEs() : Set(UATS!Node) {
	var r:Set(UATS!Node) = Set{};
	for ( be in self.bes.keySet() ) {
		if ( self.bes.get( be ) == IMA!StatusType#OPERATIONAL ) {
			r.add( be );
		}
	}
	return r;
}

// TODO: Should this function be called again and again intil there no longer is a change.
operation IMA!State setSafeStatuses ( 
	bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)),
	be:UATS!Node )  {
	while ( bottomUp.hasNext() ) {
		var gate = bottomUp.next();
		if ( self.getNodeStatus(gate) <> IMA!StatusType#OPERATIONAL ) {
			// gate already changed.
		} else {
			// TODO: Current testcasses never trigger this condition.
			switch ( gate.connector.type().name ) {
				case "AND"	:{	var status = self.calculateStatusOfAND( gate );
								if ( ( status == IMA!StatusType#FAILED ) 
									or ( status == IMA!StatusType#SAFE ) ) {
									self.setNodeStatus(gate, IMA!StatusType#SAFE);
								}
								// TODO: Can this function only set statuses to SAFE?
							}	
				case "OR"	:{	var status = self.calculateStatusOfOR( gate );
								if ( ( status == IMA!StatusType#FAILED ) 
									or ( status == IMA!StatusType#SAFE ) ) {
									self.setNodeStatus(gate, IMA!StatusType#SAFE);
								}
							}	
				case "SAND"	:{	// TODO: process new states due to race condition.
								var statuses = self.calculateStatusOfSAND( gate, null, be );
								var status = statuses.first();
								if ( statuses.size() > 1 ){ throw("TODO: setSafeStatuses returned mutiple results.");}
								if ( ( status == IMA!StatusType#FAILED ) 
									or ( status == IMA!StatusType#SAFE ) ) {
									self.setNodeStatus(gate, IMA!StatusType#SAFE);
								}
							}	
				default : throw (self.children.println("process UNKNOWN Gate!____" + gate.connector.gate.id));
			}
		}
	}
}

operation IMA!State propogateDontCareStatuses ( 
	topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)) )  {
	while ( topDown.hasNext() ) {
		var gate = topDown.next();
		if ( self.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL ) { 
			var parents = gate.parents;
			if (parents.size() > 0) {
				if ( parents.forAll( parent |  self.getNodeStatus(parent) <> IMA!StatusType#OPERATIONAL ) ) {
					// DONTCARE propogates.
					self.setNodeStatus(gate, IMA!StatusType#DONTCARE);
				}
			}
		}			
	}
}

// TODO: clean up and test with SAND and SOR.
operation markGatesReachableFromBAS(
	bottomUp: Sequence(Sequence(UATS!Node), Sequence(Integer)),	 
	BEs		: Set(UATS!Node) ) {

	// Label all children using there id.
	for ( be in BEs ) {
		be.~reachableBy = Set{ be };
	}
	// For every gate add set the Union of sets of BEs which can reach the children.
	while( bottomUp.hasNext() ) {
		var gate = bottomUp.next(); 
		gate.~reachableBy = Set{};
//		(" gate id = " + gate.id + " <-").print();
		for ( child in gate.children ) {
//			" | ".print();
			gate.~reachableBy.addAll( child.~reachableBy );
//			for (be in gate.~reachableBy) {be.id.print(" ");}
		}
		"".println();
		// At this point this gate.~reachableBy contains all the BEs which are
		// able to reach this gate.
		// Next create a map which maps BEs to children.
//		(". at gate "+ gate.id).println();
		gate.~beToChildren = Map{}; /* Map(UATS!Node,Sequence(UATS!Node)) */ 
		for ( be in gate.~reachableBy ) {
//			("..create map for be= "+ be.id ).println();
			for ( child in gate.children ){
//				child.id.println("...testing child = ");
				if ( child.~reachableBy.includes( be ) ) {
//					("....Adding " + child.id + " to " + be.id).println();
					// add child to list sources reachable by BE.
					if ( gate.~beToChildren.containsKey(be) ){
//						".....Add to existing list__".println();
						var list = gate.~beToChildren.get(be);
						list.add(child);
						gate.~beToChildren.put( be, list );					
					} else { // key does not jet exist. So initialize.
//						".....Create list__".println();
						var list = Set{ child };
						gate.~beToChildren.put( be, list );
					}
				} else {
//					child.id.println("...not child = ");
				}
			}
		}
//		("Gate "+gate.id+" done.").println();
		// Remove all BEs keys from Map (for this gate) which only have one
		// Child for a given BE.
//		("Removing keys containing single child in gate "+gate.id).println();
		
		gate.~beToChildrenFinal = Map{};
				
		for ( be in gate.~beToChildren.keySet() ) {
			var list = gate.~beToChildren.get( be );
			if ( list.size() > 1 ){
//				"Add to final Map".println();
				gate.~beToChildrenFinal.put( be, list);
				//gate.~beToChildren.remove( be ); //Somehow remove kills the process!
			}
		}
/*
		("Gate " + gate.id + " is reachable from BE: ").println();
		for ( be in gate.~beToChildrenFinal.keySet() ) {
			var list = gate.~beToChildren.get( be );
			(" " + be.id + " via -> ").print();
			for (be2 in list) {
				(" " + be2.id).print();
			}
			"".println();
		}
*/	
	}
	
}

/**********************************EOF****************************************/