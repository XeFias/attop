import "IntermediateIterator.eol";
import "IntermediateState.eol";
import "IntermediateStateMap.eol";

operation generateIntermediateAutomata( 
			attackTree:UATS!AttackTree, 
			rootNode:UATS!Node ) 
		: Sequence(IMA!State) {
	// Assotiate Gates to graph height (from bottom to top) and depth (from top to bottom)  
	var nodes	: Set(UATS!Node) = attackTree.Nodes;
	var BEs		: Set(UATS!Node) = nodes.select(n|n.children.isEmpty()).asSet();
	var bottomUp: Sequence(UATS!Node) = fromLevelMapToSequence(calculateHeightOfGates(BEs));
	var topDown	: Sequence(UATS!Node) = fromLevelMapToSequence(calculateDepthOfGates(rootNode));
	for ( be in BEs ) { topDown.add(be); }

	var gates 			= nodes.excludingAll(BEs);
	var bottomUpIterator= createIterator(bottomUp);
	var topDownIterator	= createIterator(topDown);
	var gStateMap 		= createStateMap();
	var rootState 		= constructInitialState("rootState", nodes, rootNode);
	var successGoalState= rootState.createSuccesGoal();
	var failGoalState	= rootState.createFailGoal();

	gStateMap.put(rootState);
	gStateMap.put(successGoalState);
	gStateMap.put(failGoalState);

	for ( nextStatus in Sequence{ IMA!StatusType#SUCCESS, IMA!StatusType#FAILED } ) {
		for ( be in rootState.bes.keySet() ) {
			var nextStatesBe = recur_buildIMA(	gStateMap, 
												bottomUpIterator, 
												topDownIterator, 
												rootState, 
												be.~nodeRef, 
												nextStatus );
			for ( state in nextStatesBe ) {
				("generateIntermediateAutomata Create edge from " + rootState.toString(true) + " to " + state.toString(true) + " with edge " +  be + " and new be status " + nextStatus).println();
				rootState.setDisruption( be.~nodeRef, nextStatus, state );
			}
		}
	}
	// TODO: find all success and fail goals.
	return Sequence{ rootState, successGoalState, failGoalState };
}

operation fromLevelMapToSequence( 
			levelMap:Map(UATS!Node,Sequence) ) 
: Sequence(UATS!Node) {
	var nbrOfLevels =  levelMap.values().max();
	var inversMap = inverseMapRelation(levelMap);
	var order = Sequence {};
	for (level in 1.to(nbrOfLevels)){
		order += inversMap.get(level);
	}
	return order;
}

// TODO: rename
operation recur_buildIMA(	gStateMap, 
							bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
							topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
							prevState:IMA!State, 
							be:UATS!Node, 
							nextStatus ) 
: Set(IMA!State) {

	var newState = prevState.copyState( "Generated" ); // TODO: maybe use state name as hash?
	// Set BE in state to newStatus
	newState.setNodeStatus( be, nextStatus );

	// Calculate the new statuses of the gates in this State
	var newStates = newState.calculateGateStatusesInState( bottomUp, be ); 
	var missingStates:Set(IMA!State) = Set{};
	var existingStates:Set(IMA!State) = Set{};
	var doubleStates:Set(IMA!State) = Set{};

	for ( newState in newStates ) {
		var exists:Sequence(Boolean,IMA!State) = gStateMap.get( newState );
		
		if ( exists.first() == false ) {
			// Add nonexisting state
			missingStates.add( newState );
		} else {
			// remember the existing state.
			existingStates.add( exists.second() );
			// remove doubles created.
			doubleStates.add( newState );
		}
	}

	for (state in doubleStates){
		delete state; // Make sure the doubles are deleted from the model !!!
	}
	
	for ( state in missingStates ) {
		// Propogate SAFE Statuses.
		state.setSafeStatuses( bottomUp.copyIterator() );
		// Propogate DONTCARE Statuses.
		state.propogateDontCareStatuses( topDown.copyIterator() );
	}
	
	var targetStates = missingStates.includingAll( existingStates );
		
	// Recursively process new states to create the monolithic automata.
	for ( nextState in missingStates ) {
		nextState.recur2_buildIMA( gStateMap, bottomUp, topDown);
	}

	return targetStates;
}

operation IMA!State recur2_buildIMA(	
							gStateMap, /* ? */
							bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
							topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)) ) {

	// Get remaining BEs which are still OPERASTIONAL.
	for ( be in self.getOperationalBEs() ) {
		// Process state when BE SUCCEEDS or FAILES.
		for ( nextStatus in Sequence{ IMA!StatusType#SUCCESS, IMA!StatusType#FAILED } ) {
			("Processing " + be + ", " + nextStatus).println(); 
			var nextStatesBe = recur_buildIMA(	gStateMap, 
												bottomUp,
												topDown,
												self,
												be.~nodeRef,
												nextStatus );
			for ( state in nextStatesBe ) {
				("recur2_buildIMA Create edge from " + self.toString(true) + " to " + state.toString(true) + " with edge " +  be + " and new be status " + nextStatus).println();
				self.setDisruption( be.~nodeRef, nextStatus, state );
			}
		}
	}
}

operation IMA!State calculateGateStatusesInState( 
						bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)),
						be:UATS!Node ) 
						: Set(IMA!State) {
	var DonePackets = Set{};
	var TodoPackets = Set{};
	var packetOfWork = Sequence { self, bottomUp.copyIterator(), be };
	TodoPackets.add( packetOfWork );
	
	while ( TodoPackets.size() > 0 ) {
		var work =  TodoPackets.random();
		("WorkPacket = " + work.first().toString(true) + " " + work.second().toString() + " " + be.id).println();
		TodoPackets.remove( work );
		// processPacketOfWork() can generate new packets of work due to raceconditions.
		var newPacketsOfWork = work.first().processPacketOfWork( work.second(), work.third() );
		DonePackets.add(work.first());
		TodoPackets.addAll( newPacketsOfWork );
	}
	return DonePackets;
}

//var packetOfWork = Set { Sequence { newState, bottomUp.copyIterator(), be } };
operation IMA!State processPacketOfWork(
	bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
	be		:UATS!Node )
: Set(Sequence) {
	var r:Set(Sequence(Any)) = Set{};
	"START_____".println();

	while ( bottomUp.hasNext() ) {
		var gate = bottomUp.next();
		var newStatuses = gate.calculateStatusInState( self, be );
		if ( newStatuses.size() == 1 ) {
			var status = newStatuses.first();
			self.setNodeStatus(gate, status);
		} else if ( newStatuses.size() > 1 ) {
			for ( newStatus in newStatuses ) {
				var newNextState = self.copyState( "R" );
				var bottomUpCopy = bottomUp.copyIterator();
				newNextState.setNodeStatus(gate, newStatus);
				r.add( Sequence{ newNextState, bottomUpCopy, be } );
			}
			self.setNodeStatus(gate, status);

		} else {
			throw ("When calculating the status of a Gate " + gate.id + " returned no status.");
		}
	}
	"STOP_____".println();
	return r;
}

          // Gate.
operation UATS!Node calculateStatusInState( state:IMA!State, be:UATS!Node )
: Set(Any) /*IMA!StatusType*/ {
	var r:Set() = Set{};
	switch (self.connector.type().name) {
		case "AND"	:{ r.add(state.calculateStatusOfAND(self.children)); }
		case "OR"	:{ r.add(state.calculateStatusOfOR(self.children)); }	
		case "SAND"	:{ r.add(state.calculateStatusOfSAND(self.children)); }
		default : throw (self.children.println("process UNKNOWN Gate!____" + self.connector.gate.id));
	}
	return r;
}

operation IMA!State calculateStatusOfAND( children:OrderedSet(UATS!Node) )
: Any /*IMA!StatusType*/ {
	self.toString(false).println("calculateStatusOfAND_______");
	if ( children.forAll( child |  self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		// If all childeren are SUCCESS return SUCCESS,
		"AND SUCCES".println();
		return IMA!StatusType#SUCCESS;
	} else if ( children.exists( child | 
					self.getNodeStatus(child) == IMA!StatusType#FAILED )) {
		// If any is FAILED return FAILED,
		"AND FAILED".println();
		return IMA!StatusType#FAILED;
	} else if ( children.exists( child | 
					self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
		// If any is FAILED return FAILED,
		"AND FAILED".println();
		return IMA!StatusType#SAFE;
	} else {
		// Keep gate Operational.
		"AND OPERATIONAL".println();
		return IMA!StatusType#OPERATIONAL;
	}
	// If DONTCARE ?? error because unexpected.
}

operation IMA!State calculateStatusOfOR( children:OrderedSet(UATS!Node) )
: Any /*IMA!StatusType*/ {
	if ( children.exists(
			child | self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		// If any child is SUCCESS return SUCCESS,
		return IMA!StatusType#SUCCESS;
	} else if ( children.forAll(
			child | self.getNodeStatus(child) == IMA!StatusType#FAILED
					or self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
		// If all are FAILED of SAFE return FAILED,
		return IMA!StatusType#FAILED;
	} else {
		// Keep gate Operational.
		return IMA!StatusType#OPERATIONAL;
	}
}

operation IMA!State calculateStatusOfSAND( children:OrderedSet(UATS!Node) )
: Any /*IMA!StatusType*/ {
	self.toString(false).println("calculateStatusOfSAND_______");
	if ( self.isActivatedFromLeft( children ) == false ) {
		return IMA!StatusType#SAFE;
	}

	if ( children.forAll( child |  self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		return IMA!StatusType#SUCCESS;
	} else if ( children.exists( child | 
					self.getNodeStatus(child) == IMA!StatusType#FAILED )) {
		// If any is FAILED return FAILED,
		return IMA!StatusType#FAILED;
	}

	return IMA!StatusType#OPERATIONAL;
}

operation IMA!State calculateStatusOfSOR( children:OrderedSet(UATS!Node) )
: Any /*IMA!StatusType*/ {
	throw("TODO");
	self.toString(false).println("calculateStatusOfSOR_______");
	if ( self.isActivatedFromLeft( children ) == false ) {
		return IMA!StatusType#SAFE;
	}

	if ( children.exists(
			child | self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		// If any child is SUCCESS return SUCCESS,
		return IMA!StatusType#SUCCESS;
	} else if ( children.forAll(
			child | self.getNodeStatus(child) == IMA!StatusType#FAILED
					or self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
		// If all are FAILED of SAFE return FAILED,
		return IMA!StatusType#FAILED;
	}

	return IMA!StatusType#OPERATIONAL;
}

operation IMA!State isActivatedFromLeft( children:OrderedSet(UATS!Node) ) : Boolean {  
	var next = 0;
	while ( (next <= children.size() - 1 ) // Search first child which is not yet activated 
			and ( self.getNodeStatus( children.at( next ) ) <> IMA!StatusType#OPERATIONAL ) ) {
		next++;
	}
	if ( next > children.size() - 1 ) { // If all children are activated order is correct.
		return true;
	} else { 							// Else some are stil not activated.
										// From here all must be unactivated
		while ( ( next <= children.size() - 1 ) 
				and( self.getNodeStatus( children.at( next ) ) == IMA!StatusType#OPERATIONAL ) ) {
			next++;
		}
		if ( next > children.size() - 1 ) { // All remaining children remain unactivated.
			return true;
		} else { 							// Detected yet an activated child after an
			return false;					// unactivated child.
		}
	}
}

operation IMA!State getOperationalBEs() : Set(UATS!Node) {
	var r:Set(UATS!Node) = Set{};
	for ( be in self.bes.keySet() ) {
		if ( self.bes.get( be ) == IMA!StatusType#OPERATIONAL ) {
			r.add( be );
		}
	}
	return r;
}

// TODO: Should this function be called again and again intil there no longer is a change.
operation IMA!State setSafeStatuses ( 
	bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)) )  {
	while ( bottomUp.hasNext() ) {
		var gate = bottomUp.next();
		if ( self.getNodeStatus(gate) <> IMA!StatusType#OPERATIONAL ) {
			// gate already changed.
		} else {
			switch ( gate.connector.type().name ) {
				case "AND"	:{	("SAFE? AND gate!____ " + gate.connector.gate.id).println();
								var status = self.calculateStatusOfAND( gate.children );
								if ( ( status == IMA!StatusType#FAILED ) 
									or ( status == IMA!StatusType#SAFE ) ) {
									self.setNodeStatus(gate, IMA!StatusType#SAFE);
								}
								// TODO: Can this function only set statuses to SAFE?
							}	
				case "OR"	:{	("SAFE? OR gate!____ " + gate.connector.gate.id).println();
								var status = self.calculateStatusOfOR( gate.children );
								if ( ( status == IMA!StatusType#FAILED ) 
									or ( status == IMA!StatusType#SAFE ) ) {
									self.setNodeStatus(gate, IMA!StatusType#SAFE);
								}
							}	
				case "SAND"	:{	("SAFE? SAND gate!____ " + gate.connector.gate.id).println();
								self.toString(false).println("SAND in _____");
								var status = self.calculateStatusOfSAND( gate.children );
								if ( ( status == IMA!StatusType#FAILED ) 
									or ( status == IMA!StatusType#SAFE ) ) {
									self.setNodeStatus(gate, IMA!StatusType#SAFE);
								}
								self.toString(false).println("SAND out _____");
							}	
				default : throw (self.children.println("process UNKNOWN Gate!____" + gate.connector.gate.id));
			}
		}
	}
	return;
}

operation IMA!State propogateDontCareStatuses ( 
	topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)) )  {
	while ( topDown.hasNext() ) {
		var gate = topDown.next();
		if ( self.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL ) { 
			var parents = gate.parents;
			if (parents.size() > 0) {
				if ( parents.forAll( parent |  self.getNodeStatus(parent) <> IMA!StatusType#OPERATIONAL ) ) {
					// DONTCARE propogates.
					self.setNodeStatus(gate, IMA!StatusType#DONTCARE);
				}
			}
		}			
	}
}

// TODO: clean up and test with SAND and SOR.
operation markGatesReachableFromBAS(
	bottomUp: Sequence(Sequence(UATS!Node), Sequence(Integer)),	 
	BEs		: Set(UATS!Node) ) {

	// Label all children using there id.
	for ( be in BEs ) {
		be.~reachableBy = Set{ be };
	}

	// For every gate add set the Union of sets of BEs which can reach the children.
	while( bottomUp.hasNext() ) {
		var gate = bottomUp.next(); 
		gate.~reachableBy = Set{};
		for ( child in gate.children ) {
			gate.~reachableBy.addAll( child.~reachableBy );
//			gate.~reachableBy.println("gate id=" + gate.id + "__");
		}
		// At this point this gate.~reachableBy contains all the BEs which are
		// able to reach this gate.
		// Next create a map which maps BEs to children.
		gate.~beToChildren = Map{};
		for ( be in gate.~reachableBy ) {
//			("..create map for be= "+ be.id +" at gate "+ gate.id).println();
			for ( child in gate.children ){
//				child.id.println("...testing child = ");
				if ( child.~reachableBy.includes( be ) ) {
//					("....Adding " + child.id + " to " + be.id).println();
					// add child to list sources reachable by BE.
					if ( gate.~beToChildren.containsKey(be) ){
//						".....Add to existing list__".println();
						var list = gate.~beToChildren.get(be);
						list.add(child);
						gate.~beToChildren.put( be, list );					
					} else { // key does not jet exist. So initialize.
//						".....Create list__".println();
						var list = Set{ child };
						gate.~beToChildren.put( be, list );
					}
				} else {
//					child.id.println("...not child = ");
				}
			}
		}
//		("Gate "+gate.id+" done.").println();
		// Remove all BEs keys from Map (for this gate) which only have one
		// Child for a given BE.
//		("Removing keys containing single child in gate "+gate.id).println();
		
		gate.~beToChildrenFinal = Map{};
				
		for ( be in gate.~beToChildren.keySet() ) {
			var list = gate.~beToChildren.get( be );
			if ( list.size() > 1 ){
//				"Add to final Map".println();
				gate.~beToChildrenFinal.put( be, list);
				//gate.~beToChildren.remove( be ); //Somehow remove kills the process!
			}
		}
//		("Remaining keys containing single child in gate "+gate.id).println();
		for ( be in gate.~beToChildrenFinal.keySet() ) {
			var list = gate.~beToChildren.get( be );
//			list.size().println("______  ");
		}
		
	}
	
	// create a map from BeId to child
	
	
	
	

}

/**********************************EOF****************************************/