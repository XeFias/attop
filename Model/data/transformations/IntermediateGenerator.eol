import "IntermediateIterator.eol";
import "IntermediateState.eol";
import "IntermediateStateMap.eol";
import "IntermediateStd.eol";

operation generateIntermediateAutomata( 
			attackTree:UATS!AttackTree,
			rootNode:UATS!Node ) 
		: IMA!InterimAutomaton {
	var detectedIFAIL = false;
	var Domains : Set(String) = domains();
	// Assotiate Gates to graph height (from bottom to top) and depth (from top to bottom)  
	var nodes	: Set(UATS!Node) = attackTree.Nodes;
	var BEs		: Set(UATS!Node) = nodes.select(n|n.children.isEmpty()).asSet();
	var bottomUp: Sequence(UATS!Node) = fromLevelMapToSequence(calculateHeightOfGates(BEs));
	var topDown	: Sequence(UATS!Node) = fromLevelMapToSequence(calculateDepthOfGates(rootNode));
	for ( be in BEs ) { topDown.add(be); } // Add BEs to the tail of the topDown iterator.

	var gates 			= nodes.excludingAll(BEs);
	var bottomUpIterator= createIterator(bottomUp);
	var topDownIterator	= createIterator(topDown);
	var gStateMap 		= createStateMap();
	var rootState 		= constructInitialState("rootState", nodes, rootNode);
	var successGoalState= rootState.createSuccesGoal();
	var failGoalState	= rootState.createFailGoal();
	var finalState		= rootState.createFinal();
	var finalStates		= Map{	IMA!GoalState#SUCCESS	= successGoalState,
								IMA!GoalState#FAIL		= failGoalState};

	attackTree.addValuesToAllNodes(Domains);
	
	successGoalState.setDisruption( IMA!StatusType#SUCCESS, finalState );
	failGoalState.setDisruption( IMA!StatusType#FAILED, finalState );
								
	gStateMap.put(rootState);
	gStateMap.put(successGoalState);
	gStateMap.put(failGoalState);

	// Mark the gates in the attack-tree with a Map describing there reachability.
	// Retrieve gate rechability data
	var reachabilityRules = markGatesReachableFromBAS( bottomUpIterator.copyIterator(), BEs );
	// Normalize rechability data
	var reachabilityRulesnormalized = normalizeReachabilityRules( reachabilityRules );

	var invalidBEs = reachabilityRulesnormalized.invalidBEOptions();
	var selection = rootState.bes.keySet().select( beId | invalidBEs.collect(n|n.id).excludes( beId ) );
	
//	var IFAILs = getIFAILs( selection );
//	if ( IFAILs.size() > 0 ) { selection = IFAILs; }

	for ( be in selection ) {
	//for ( be in rootState.bes.keySet() ) {
		// New state E representing attack / Markovian state
		// New disruption/transition from rootState to E with label BE + rate
		// New state F representing probabolistic state
		// New disruption/transition from E to F with label BE
		
		for ( nextStatus in Sequence{ IMA!StatusType#SUCCESS, IMA!StatusType#FAILED } ) {
			// Do not follow transitions for which be corresponding probability equals 0%.
			// Note: this is only relevant for MA
			if ( not skipExploringThisPath( be.~nodeRef, nextStatus, detectedIFAIL ) ) {
				var nextStatesBe = recur_buildIMA(	gStateMap,		// hashmap containing all generated states 
													bottomUpIterator,
													topDownIterator,
													finalStates,	// the FAIL and SUCCESS automata state
													reachabilityRulesnormalized,
													rootNode,		// attack-tree rootGate
													rootState,		// root of automata
													be.~nodeRef, 	// reference to actual attack-tree gate
													nextStatus ); 	// new node statues in next automata state.
				for ( state in nextStatesBe ) {
					/*state F.*/ rootState.setDisruption( be.~nodeRef, nextStatus, state /*, probability*/);
				}
				// when the valid execution of an IFAIL-BE has been detected only 
				// process IFAIL-BEs as represent instantanious execution (no Rate)
				if ( not detectedIFAIL ) { 
					detectedIFAIL = ( nextStatesBe.size() > 0 and be.~nodeRef.isIFAIL() );
				}		 
			}
		}
	}


	// TODO: move the code which add the rates to de IMA here when the problem
	//  is solved in which eunit is not able to handel models with dependencies.
	
	var IMA = new IMA!InterimAutomaton;	
	IMA.rootState = rootState;
	IMA.successGoal = successGoalState;
	IMA.failureGoal = failGoalState;

	// Marknodes which are created before detecting valid IFAIL on correspinding state
	var states:Sequence(IMA!State) = IMA!State.allInstances();
	introduceSelfLoopsForIFAIL( states, rootState );

	var disruptions:Sequence(IMA!Disruption) = IMA!Disruption.allInstances();
	states.size().println( "Pre: states.size() = " );
	disruptions.size().println( "Pre: disruptions.size() = " );
	removeUnreachableNodes( rootState, states );

	states = IMA!State.allInstances();
	disruptions = IMA!Disruption.allInstances();
	states.size().println( "Post: states.size() = " );
	disruptions.size().println( "Pre: disruptions.size() = " );

	// Uniquely number all states.
	var disruptions:Sequence(Disruption) = IMA!Disruption.allInstances();
	generateIDForAllStates( disruptions );


	for ( state in states ) {
		if ( state.name == "Generated" or state.name == "Previous ??") { 
			state.toString(true).println("Generated source state occured at collection stage.");
			IMA.states.add( state );
		}
		IMA.states.add( state );
	}

	return IMA;
}

operation fromLevelMapToSequence( 
			levelMap:Map(UATS!Node,Sequence) ) 
: Sequence(UATS!Node) {
	var nbrOfLevels =  levelMap.values().max();
	var inversMap = inverseMapRelation(levelMap);
	var order = Sequence {};
	for (level in 1.to(nbrOfLevels)){
		order += inversMap.get(level);
	}
	return order;
}

// TODO: rename
operation recur_buildIMA(	gStateMap:Map(Integer, Sequence(IMA!State)), 
							bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
							topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)),
							finalStates:Map(Any,IMA!State),/* Any is StatusType */
							rules:Sequence(Sequence(Set(UATS!Node))),
							rootNode:UATS!Node, 
							prevState:IMA!State, 
							be:UATS!Node, 
							nextStatus ) 
: Set(IMA!State) {
	var newState = prevState.copyState( "Generated" ); // TODO: maybe use state name as hash?
	
	// Set BE in state to newStatus
	newState.setNodeStatus( be, nextStatus );
	// Calculate the new statuses of the gates in this State
	var newStates = newState.calculateGateStatusesInState( bottomUp, prevState, be );
	
	// Multiple new states have been ceated replacing the state which was being processed.
	// As such this state must be removed.
	if (newStates.size() > 1) {
		delete newState;
	}

	var missingStates:Set(IMA!State) = Set{};
	var existingStates:Set(IMA!State) = Set{};
	var doubleStates:Set(IMA!State) = Set{};
	
	for ( newState in newStates ) {

		// Propogate SAFE Statuses. ()
		newState.setSafeStatuses( bottomUp.copyIterator(), be );
		
		if ( newState.getNodeStatus(rootNode) == IMA!StatusType#SAFE ){
			newState.setNodeStatus(rootNode, IMA!StatusType#FAILED);
		}
		// Propogate DONTCARE Statuses.
		newState.propogateDontCareStatuses( topDown.copyIterator() );

		// Check if this state already exists 
		var exists:Sequence(Boolean,IMA!State) = gStateMap.get( newState );
		
		if ( exists.first() == false ) {
			gStateMap.put( newState );
			// Add nonexisting state
			missingStates.add( newState );
		} else {
			// remember the existing state.
			existingStates.add( exists.second() );
			// forget/remove the doubles
			doubleStates.add( newState );
		}
	}

	for (state in doubleStates){
		state.name = "deleted";
		delete state; // Make sure the double states are deleted from the model !!!
	}

	// The caller will create transitions to the state which are returned. This
	// must include the excisting state which are reached. 
	var targetStates = missingStates.includingAll( existingStates );

	//TODO: At this point the algotithm could add the egdes (Distuptions) from 
	// the rootstate(previous) to then new states target stats before continuing
	// to process these new states.  


	// Recursively process new states to create the monolithic automata.
	for ( nextState in missingStates ) {
		nextState.recur2_buildIMA( gStateMap, bottomUp, topDown, finalStates, rules, rootNode);
	}

	return targetStates;
}

operation IMA!State recur2_buildIMA(	
							gStateMap:Map(Integer, Sequence(IMA!State)),
							bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
							topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)),
							finalStates:Map(Any,IMA!State), /* Any = StatusType */
							rules:Sequence(Sequence(Set(UATS!Node))),
							rootNode:UATS!Node ) {
	var detectedIFAIL = false;
	var filtered = removeNodeFromRules( rules, self.getNoneOperationalBEs() );
	var invalidBEs = filtered.invalidBEOptions();
	var selection = self.getOperationalBEs().select( beId | invalidBEs.collect(n|n.id).excludes( beId ) );
//	var IFAILs = getIFAILs( selection );
//	if ( IFAILs.size() > 0 ) { selection = IFAILs; }

	// Get remaining BEs which are still OPERATIONAL.
	//for ( be in selection ) {
	for ( be in self.getOperationalBEs() ) {
		// Process state when BE SUCCEEDS or FAILS.
		for ( nextStatus in Sequence{ IMA!StatusType#SUCCESS, IMA!StatusType#FAILED } ) {
			if ( not skipExploringThisPath( be.~nodeRef, nextStatus, detectedIFAIL ) ) {
				var nextStatesBe = recur_buildIMA(	gStateMap, 
													bottomUp,
													topDown,
													finalStates,
													rules,
													rootNode,
													self,
													be.~nodeRef,
													nextStatus );
				for ( state in nextStatesBe ) { // Create an edge to the new states with BE action as a label.  
					self.setDisruption( be.~nodeRef, nextStatus, state );
				}
				// when the valid execution of an IFAIL-BE has been detected only 
				// process IFAIL-BEs as represent instantanious execution (no Rate)
				if ( not detectedIFAIL ) {
					detectedIFAIL = ( nextStatesBe.size() > 0 and be.~nodeRef.isIFAIL() );
				}		 
			}
		}
		// Outgoing disruptions are set now
	}
}

operation IMA!State calculateGateStatusesInState( 
						bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)),
						prevState:IMA!State,
						be:UATS!Node ) 
						: Set(IMA!State) {
	var DonePackets = Set{};
	var TodoPackets = Set{};
	// A packet of work is collection containing:
	// 	1. a partly processed AT-state,
	//	2. a parly processed iterator describing how far the AT-state has been processed.
	//	3. the BES which caused the calculation of the new AT-state.      
	var packetOfWork = Sequence { self, bottomUp.copyIterator(), be };
	TodoPackets.add( packetOfWork );
	
	while ( TodoPackets.size() > 0 ) {
		var work =  TodoPackets.random();
		TodoPackets.remove( work );
		// processPacketOfWork() can generate new packets of work due to raceconditions.
		var resultAndnewPacketsOfWork = work.first().processPacketOfWork( work.second(), prevState, work.third() );
		var valid = resultAndnewPacketsOfWork.first();
		var newPacketsOfWork = resultAndnewPacketsOfWork.second();
		
		if ( valid ) { 
			if (newPacketsOfWork.size() == 0) {
				// activation of this 'be' did not result in any new states.
				DonePackets.add(work.first());
			} else if (newPacketsOfWork.size() == 1) {
				// The last packet detected a race-condition. And as such is replaced by the new packets.
				DonePackets.add(work.first());
			} else {
				// 
			}
		} else {
			// Processing of the BES activation resulted in a invalid AT-state
			delete self;
		}
		TodoPackets.addAll( newPacketsOfWork );
	}
	return DonePackets; // set of new target AT states.
}

operation IMA!State processPacketOfWork(
	bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)),
	prevState:IMA!State, 
	be		:UATS!Node )
: Collection(Boolean,Set(Sequence)) { /* = (Boolean, Set { Sequence { newState, bottomUp.copyIterator(), be } }) */
	var r:Set(Sequence(Any)) = Set{};
	var valid = true;

	while ( bottomUp.hasNext() and valid ) { // Iterate over gates.
		var gate = bottomUp.next(); // Next gate
		var ValidAndnewStatuses = gate.calculateStatusInState( self, prevState, be );
		if( ValidAndnewStatuses.first() == true ){ // valid 'be' activation.
			var newStatuses = ValidAndnewStatuses.second();
			
			if ( newStatuses.size() == 1 ) {// Changing 'be' in the current state did
				var status = newStatuses.first();
				self.setNodeStatus(gate, status);
			} else if ( newStatuses.size() > 1 ) {	// Racecondition occured.
				for ( newStatus in newStatuses ) {
					// Create a packet of work for all possible statuses 
					// to be processed in the future.
					var newNextState = self.copyState( "R" );
					var bottomUpCopy = bottomUp.copyIterator();
					newNextState.setNodeStatus(gate, newStatus);
					r.add( Sequence{ newNextState, bottomUpCopy, be } );
				}
			} else {
				// When calculating the status of a Gate when 'be' changed returned no status.
			}
		} else { // invalid 'be' activation.
			valid = false;
			r = Set{};
		}
	} // State 'self' is processed in the bottom-up direction
	return Collection{valid,r}; // New work packets due to race condition.
}

          // Gate.
operation UATS!Node calculateStatusInState( state:IMA!State, prevState:IMA!State, be:UATS!Node )
: Collection(Boolean,Set(Any)) /*IMA!StatusType*/ {
	var r = Collection{};
	switch (self.connector.type().name) {
		case "AND"	:{ r = Collection{ true, Set{ state.calculateStatusOfAND(self) } }; }
		case "OR"	:{ r = Collection{ true, Set{ state.calculateStatusOfOR(self) } }; }	
		case "SAND"	:{ r = state.calculateStatusOfSequentialGate(self, prevState, be ); }
		case "SOR"	:{ r = state.calculateStatusOfSequentialGate(self, prevState, be ); }
		case "PAND"	:{ r = state.calculateStatusOfSequentialGate(self, prevState, be ); }
		case "POR"	:{ r = state.calculateStatusOfSequentialGate(self, prevState, be ); }
		default : throw (self.children.println("process UNKNOWN Gate type!____" 
						+ self.connector.gate.id));
	}
	return r;
}

operation IMA!State calculateStatusOfAND( gate:UATS!Node )
: Any /*IMA!StatusType*/ {
	if ( self.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL ) {
		if ( gate.children.forAll( child |  self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
			// If all childeren are SUCCESS return SUCCESS,
			return IMA!StatusType#SUCCESS;
		} else if ( gate.children.exists( child | 
						self.getNodeStatus(child) == IMA!StatusType#FAILED )) {
			// If any has failed is FAILED return FAILED,
			return IMA!StatusType#FAILED;
		} else if ( gate.children.forAll( child |  
						self.getNodeStatus(child) == IMA!StatusType#SUCCESS 
						or self.getNodeStatus(child) == IMA!StatusType#SAFE ) ) {
			// If atleast one is SAFE and the rest is SUCCESS return SAFE
			return IMA!StatusType#SAFE;
		} else {
			// Keep gate Operational.
			return IMA!StatusType#OPERATIONAL;
		}
	}
	return self.getNodeStatus(gate);
	// If DONTCARE ?? error because unexpected.
}

operation IMA!State calculateStatusOfOR( gate:UATS!Node )
: Any /*IMA!StatusType*/ {
	if ( self.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL ) {
		if ( gate.children.exists(
				child | self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
			// If any child is SUCCESS return SUCCESS,
			return IMA!StatusType#SUCCESS;
		} else if ( gate.children.forAll(
				child | self.getNodeStatus(child) == IMA!StatusType#FAILED
						or self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
				if (gate.children.exists(
					child | self.getNodeStatus(child) == IMA!StatusType#SAFE ) ) {
					// If atleast one is SAFE and the rest is FAILED return SAFE
					return IMA!StatusType#SAFE;
				} else {
					// If all are FAILED return FAILED,
					return IMA!StatusType#FAILED;
				}
		} else {
			// Keep gate Operational.
			return IMA!StatusType#OPERATIONAL;
		}
	}
	return self.getNodeStatus(gate);
}

// TODO: How are possible race conditions implemented in DFTCalc and STORM?
operation IMA!State calculateStatusOfSequentialGate( gate:UATS!Node, prevState:IMA!State, be:UATS!Node )
: Collection(Boolean,Set(Any)) /* (Boolean, Set(IMA!StatusType)) */ {
	var out = Set{};
	var statuses = Set{};
	var validActivation = true;
	//	gate.~beToChildrenFinal: describes via which children of the gate BE can
	//  reach the gate. It only mentions BEs which can reach the gate via multiple
	//  children resulting in race conditions. This information is only of importance
	//  to SAND and SOR gates.
	if ( self.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL ) {
		// First test if the childeren of this gate including their decendants
		// are activated in a correct of order.
/*		if ( gate.connector.type().name == "SAND" or gate.connector.type().name == "SOR" ) {
			validActivation = self.isActivatedFromLeft( gate, be );
		}
*/		
		if ( validActivation ) {
			// If not activated out of order handle potential race condition. 
			var bes = gate.~beToChildrenFinal.keySet(); // retrieve 'be' which participate in the racecondition.
			if ( bes.includes( be ) and (prevState <> null) ) { // TODO prevent passing null.
				// Because 'be' can reach this gate via multiple children activation of
				// this 'be' could possibly generate multiple outcomes
				// Now check what happens when only one child is changed before all others.
				
				// Create a temperary state in which the childeren of this gate are reset.
				// 1. Copy children from previous state
				var resetState = self.copyState("resetState");
				// 2. Reset children which participate in a race condition to the 
				//    previous status.
				for ( childB in gate.~beToChildrenFinal.get( be ) ) {
					var prevStatus = prevState.getNodeStatus( childB );
					resetState.setNodeStatus( childB, prevStatus );
				}
		
				// TODO: move to upfront calculation to start of generateIntermediateAutomata()
				var childSequences = gate.~sequences;
				// Generate the cartesian product of orders in which the changes of the 'bes' can occure.
				// var childSequences = gate.~beToChildrenFinal.get( be ).asSequence().combinations();
				
				// Calculate all possible statues.
				for ( childSequence in childSequences ) {
				
					var tempState = resetState.copyState("tempState");
					var newStatus = IMA!StatusType#OPERATIONAL;
					// Determine the status when childere are set in the sequence.
					for ( child in childSequence ) {
						var newChildStatus = self.getNodeStatus( child );
						tempState.setNodeStatus( child, newChildStatus );
						if ( tempState.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL) {
							switch (gate.connector.type().name) {
								case "SAND"	:{ newStatus = tempState.calculatedStatusOfSAND( gate );}
								case "SOR"	:{ newStatus = tempState.calculatedStatusOfSOR( gate ); }
								case "PAND"	:{ newStatus = tempState.calculatedStatusOfSAND( gate ); }
								case "POR"	:{ newStatus = tempState.calculatedStatusOfSOR( gate ); }
								default : throw (self.children.println("process UNKNOWN Gate!____" 
												+ self.connector.gate.id));
							}
							if ( newStatus <> IMA!StatusType#OPERATIONAL ) {
								statuses.add( newStatus );  // When the status changes we
								break;						// are done for this activation sequence.
							}
						} else {
							newStatus = tempState.getNodeStatus(gate);
							statuses.add( tempState.getNodeStatus(gate) );
						}
					}
					// After completion of a sequence the gate state is still OPERATIONAL.
					// This should be added as on off the new states.
					if ( newStatus == IMA!StatusType#OPERATIONAL ) {
						statuses.add( newStatus );
					}
					delete tempState;
				}
				delete resetState;
			} else {
				// No race-condition.
				if ( self.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL) {
					switch (gate.connector.type().name) {
						case "SAND"	:{ statuses.add( self.calculatedStatusOfSAND( gate ) ); }
						case "SOR"	:{ statuses.add( self.calculatedStatusOfSOR( gate ) ); }
						case "PAND"	:{ statuses.add( self.calculatedStatusOfSAND( gate ) ); }
						case "POR"	:{ statuses.add( self.calculatedStatusOfSOR( gate ) ); }
						default : throw (self.children.println("process UNKNOWN Gate!____" 
										+ self.connector.gate.id));
					}
				} else {
					statuses.add( self.getNodeStatus(gate) );
				}
			}
		} else { // Invalid action.
			// Skip gate as its allready changes state.
		}
		// At this point 'statuses' contains all statuses which can occure for 
		// this gate during this transition.
		if ( (gate.connector.type().name == "SAND") 
			or (gate.connector.type().name == "SOR" )) {
			out = statuses.excluding( IMA!StatusType#OPERATIONAL );
			// If SAFE of SUCCESS is the only status which can occure the gate 
			// is reached a invalid status. When more the one status are possible
			// only pass the ones which are not SAFE OF SUCCESS.
			if ( (out.size() == 1) and (statuses.first() == IMA!StatusType#SAFE) ) {
				validActivation = false;
			} else if ( statuses.size() > 1 ) {
				out = statuses.excluding( IMA!StatusType#SAFE );
			} else {
				
			}
		} else {
			out = statuses;
		}
	}
	return Collection{validActivation, out};
}

operation IMA!State calculatedStatusOfSAND( gate:UATS!Node ) 
:Any /* Set(IMA!StatusType) */ {
	if ( self.isActivatedFromLeft( gate.children ) == false ) {
		return IMA!StatusType#SAFE;
	}

	if ( gate.children.forAll( child |  self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		// If all are SUCCESS return SUCCESS,
		return IMA!StatusType#SUCCESS;
	} else if ( gate.children.exists( child | 
					self.getNodeStatus(child) == IMA!StatusType#FAILED )) {
		// If any is FAILED return FAILED,
		return IMA!StatusType#FAILED;
	} else if ( gate.children.forAll( child |  
					self.getNodeStatus(child) == IMA!StatusType#SUCCESS 
					or self.getNodeStatus(child) == IMA!StatusType#SAFE ) ) {
		// If atleast one is SAFE and the rest is SUCCESS return SAFE
		return IMA!StatusType#SAFE;
	}
	
	return IMA!StatusType#OPERATIONAL;
}

operation IMA!State calculatedStatusOfSOR( gate:UATS!Node )
: Any /*IMA!StatusType*/ {
	if ( self.isActivatedFromLeft( gate.children ) == false ) {
		return IMA!StatusType#SAFE;
	}

	if ( gate.children.exists(
			child | self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		// If any child is SUCCESS return SUCCESS,
		return IMA!StatusType#SUCCESS;
	} else if ( gate.children.forAll(
			child | self.getNodeStatus(child) == IMA!StatusType#FAILED
					or self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
		if (gate.children.exists(
			child | self.getNodeStatus(child) == IMA!StatusType#SAFE ) ) {
			// If atleast one is SAFE and the rest is FAILED return SAFE
			return IMA!StatusType#SAFE;
		} else {
			return IMA!StatusType#FAILED;
		}
	}

	return IMA!StatusType#OPERATIONAL;
}

// Test if the childeren of this gate (not including their decendants) are being 
// activated in a correct of order.
operation IMA!State isActivatedFromLeft( children:OrderedSet(UATS!Node) ) : Boolean {  
	var next = 0;
	while ( (next <= children.size() - 1 ) // Search first child which is not yet activated 
			and ( self.getNodeStatus( children.at( next ) ) <> IMA!StatusType#OPERATIONAL ) ) {
		next++;
	}
	if ( next > children.size() - 1 ) { // If all children are activated order is correct.
		return true;
	} else { 							// Else some are stil not activated.
										// From here all must be unactivated
		while ( ( next <= children.size() - 1 ) 
				and( self.getNodeStatus( children.at( next ) ) == IMA!StatusType#OPERATIONAL ) ) {
			next++;
		}
		if ( next > children.size() - 1 ) { // All remaining children remain unactivated.
			return true;
		} else { 							// Detected yet an activated child after an
			return false;					// unactivated child.
		}
	}
}

// Test if the childeren of this gate including their decendants are being 
// activated in a correct of order.
operation IMA!State isActivatedFromLeft( gate:UATS!Node, be:UATS!Node ) : Boolean {
	// get children reachable by the current 'be'.
	// Collect all 'bes' which can reach this gate.
	var next = Set{};
	var prev = Set{};
	for ( child in gate.children ) {
		next = next.includingAll( child.~reachableBy );
	}

	// Check the statuses of the childeren from left to right and verify that
	// BES, which is activated does not activate before the left part of the 
	// AT-tree is processed first.  	
	for ( child in gate.children ) {
		prev = prev.includingAll( child.~reachableBy ); 
		next = next.excludingAll( child.~reachableBy );
		if (	( self.getNodeStatus( child ) == IMA!StatusType#OPERATIONAL )
			and ( not prev.includes( be ) )
			and ( next.includes( be ) ) 
		) {
			return false;
		}
	}
	return true;
}


operation IMA!State getOperationalBEs() : Set(UATS!Node) {
	var r:Set(UATS!Node) = Set{};
	for ( be in self.bes.keySet() ) {
		if ( self.bes.get( be ) == IMA!StatusType#OPERATIONAL ) {
			r.add( be );
		}
	}
	return r;
}

operation IMA!State getNoneOperationalBEs() : Set(UATS!Node) {
	var r:Set(UATS!Node) = Set{};
	for ( be in self.bes.keySet() ) {
		if ( self.bes.get( be ) <> IMA!StatusType#OPERATIONAL ) {
			r.add( be );
		}
	}
	return r;
}

// TODO: Should this function be called again and again intil there no longer is a change.
operation IMA!State setSafeStatuses ( 
	bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)),
	be:UATS!Node )  {
	while ( bottomUp.hasNext() ) {
		var gate = bottomUp.next();
		if ( self.getNodeStatus(gate) <> IMA!StatusType#OPERATIONAL ) {
			// The status of this Gate has already changed and does not need 
			// to be calculated again. 
		} else {
			switch ( gate.connector.type().name ) {
				case "AND"	:{	var status = self.calculateStatusOfAND( gate ); }	
				case "OR"	:{	var status = self.calculateStatusOfOR( gate ); }	
				case "SAND"	:{	// NOTE: When a race condition has occured 
								// recalculating the status of a SAND could 
								// potentially generate an excisting state 
								// which will subsequantly be removed. 
								var status = self.calculatedStatusOfSAND( gate );
							}	
				case "SOR"	:{	// NOTE: When a race condition has occured 
								// recalculating the status of a SOR could 
								// potentially generate an excisting state 
								// which will subsequantly be removed. 
								var status = self.calculatedStatusOfSOR( gate );
							}	
				case "PAND"	:{	// NOTE: When a race condition has occured 
								// recalculating the status of a PAND could 
								// potentially generate an excisting state 
								// which will subsequantly be removed. 
								var status = self.calculatedStatusOfSAND( gate );
							}	
				case "POR"	:{	// NOTE: When a race condition has occured 
								// recalculating the status of a POR could 
								// potentially generate an excisting state 
								// which will subsequantly be removed. 
								var status = self.calculatedStatusOfSOR( gate );
							}	
				default : throw (self.children.println("process UNKNOWN Gate!____" + gate.connector.gate.id));
			}
			if ( ( status == IMA!StatusType#FAILED ) 
				or ( status == IMA!StatusType#SAFE ) ) {
				self.setNodeStatus(gate, IMA!StatusType#SAFE);
			}
		}
	}
}

// Propagation of the Dont-care statuses through the attack-tree occures in a 
// top down matter. When all the parents of BES of a Gate are no longer 
// Operational its status can no longer influence the state of the AT.
operation IMA!State propogateDontCareStatuses ( 
	topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)) )  {
	while ( topDown.hasNext() ) {
		var gate = topDown.next();
//		if ( self.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL ) { 
			var parents = gate.parents;
			if (parents.size() > 0) {
				if ( parents.forAll( parent |  self.getNodeStatus(parent) <> IMA!StatusType#OPERATIONAL ) ) {
					// DONTCARE propogates.
					self.setNodeStatus(gate, IMA!StatusType#DONTCARE);
				}
			}
//		}			
	}
}

// Label each Gate with the set of BESs which can reach/influence/modify it.
operation markGatesReachableFromBAS(
	bottomUp: Sequence(Sequence(UATS!Node), Sequence(Integer)),	 
	BEs		: Set(UATS!Node) ) : Sequence(Sequence(Set(UATS!Node))) {
	var reachabilityRules : Sequence(Sequence(Set(UATS!Node))) = Sequence{};
	// Label all children using there id.
	for ( be in BEs ) {
		be.~reachableBy = Set{ be };
	}
	// For every gate add set the Union of sets of BEs which can reach the children.
	while( bottomUp.hasNext() ) {
		var gate = bottomUp.next();

		var reachabilityPerPort : Sequence(Set(UATS!Node)) = Sequence{};
		for ( child in gate.children ) {
			reachabilityPerPort.add(child.~reachableBy);
		}
		// Add expected sequence base on SAND and SOR gates.
		if ( gate.connector.type().name == "SAND" or gate.connector.type().name == "SOR" ) {
			reachabilityRules.add( reachabilityPerPort );
		}
		gate.~reachableBy = Set{};
		for ( port in reachabilityPerPort ) {
			gate.~reachableBy.addAll( port );
		}
/*		for ( child in gate.children ) {
			gate.~reachableBy.addAll( child.~reachableBy );
		}
*/
		// At this point this gate.~reachableBy contains all the BEs which are
		// able to reach this gate.
		// Next create a map which maps BEs to children.
		gate.~beToChildren = Map{}; /* Map(UATS!Node,Sequence(UATS!Node)) */ 
		for ( be in gate.~reachableBy ) {
			for ( child in gate.children ){
				if ( child.~reachableBy.includes( be ) ) {
					// add child to list sources reachable by BE.
					if ( gate.~beToChildren.containsKey(be) ){
						// Add to existing list;
						var list = gate.~beToChildren.get(be);
						list.add(child);
						gate.~beToChildren.put( be, list );					
					} else { // key does not jet exist. So initialize.
						var list = Set{ child };
						gate.~beToChildren.put( be, list );
					}
				} else {
					// Not child
				}
			}
		}
		// Remove all BEs keys from Map (for this gate) which only have one
		// Child for a given BE. These can not cause a racecondition
		gate.~beToChildrenFinal = Map{};
				
		for ( be in gate.~beToChildren.keySet() ) {
			var list = gate.~beToChildren.get( be );
			if ( list.size() > 1 ){
				gate.~beToChildrenFinal.put( be, list);
				// Create set of possible child activation sequences. 
				// And also add this as an Extended Proplerty.  	 
				gate.~sequences = gate.~beToChildrenFinal.get( be ).asSequence().combinations();
			}
		}

		delete gate.~beToChildren;
	}
	return reachabilityRules;
}

operation generateIDForAllStates( disruptions:Sequence(IMA!Disruption) ) {
	var id:Integer = 4; // Solve magic number. Relate it to number of resurved IMA:GoalStates
	
	for (disruption:IMA!Disruption in disruptions) {
		if ( disruption.source.name == "deleted") { disruption.source.toString(true).println("deleted source state not deleted in source"); }
		if ( disruption.target.name == "deleted") { disruption.target.toString(true).println("deleted source state not deleted in target"); }
		// Set id of source state if not set
		if ( disruption.source.id == -1 ) {
			disruption.source.id = id;
			if ( ( disruption.source.name <> IMA!GoalState#FAIL.toString() ) 
				and ( disruption.source.name <> IMA!GoalState#SUCCESS.toString() ) ) {
				disruption.source.name = id.toString();
			}
			id++;
		}

		// Set id of target state if not set
		if ( disruption.target.id == -1 ) {
			disruption.target.id = id;
			if ( ( disruption.target.name <> IMA!GoalState#FAIL.toString() ) 
				and ( disruption.target.name <> IMA!GoalState#SUCCESS.toString() ) ) {
				disruption.target.name = id.toString();
			}
			id++;
		}
	}
}
// This operation tests for properties which make it possible to skip this transitsion.
operation skipExploringThisPath( be: UATS!Node, nextStatus, detectedIFAIL:Boolean ) : Boolean {
	if( be.~values <> null ) { // Do not skip if property .~values is not set
		if ( detectedIFAIL and not be.isIFAIL() ) {
			return true;
		}

		if ( be.nature == UATS!Nature#Fault ) { // be is a Fault 
			var rate = be.~values.get(IMA!ValueKeys#RATE);
			var prob = be.~values.get(IMA!ValueKeys#PROBABILITY);
			// be has Rate and Probablility there is only successfull transition. 
			if ( rate <> null and prob == null and nextStatus == IMA!StatusType#FAILED ) {
				return true;
			}
		}
		if ( be.~values.get(IMA!ValueKeys#PROBABILITY) <> null ) { // Do not skip if probability is not set
			if ((be.~values.get(IMA!ValueKeys#PROBABILITY) == 0 and nextStatus == IMA!StatusType#SUCCESS) or 
				(be.~values.get(IMA!ValueKeys#PROBABILITY) == 1 and nextStatus == IMA!StatusType#FAILED)) {
				// Skip when the probability of the transition is 0%.
				return true;
			}
		}
	}
	return false;
}



/**********************************EOF****************************************/