import "IntermediateIterator.eol";
import "IntermediateState.eol";


operation generateIntermediateAutomata( 
			attackTree:UATS!AttackTree, 
			rootNode:UATS!Node ) 
		: Sequence(IMA!State) {
	// Assotiate Gates to graph height (from bottom to top) and depth (from top to bottom)  
	var nodes	: Set(UATS!Node) = attackTree.Nodes;
	var BEs		: Set(UATS!Node) = nodes.select(n|n.children.isEmpty()).asSet();
	var bottomUp: Sequence(UATS!Node) = fromLevelMapToSequence(calculateHeightOfGates(BEs));
	var topDown	: Sequence(UATS!Node) = fromLevelMapToSequence(calculateDepthOfGates(rootNode));

	var gates = nodes.excludingAll(BEs);
	
	var bottomUpIterator= createIterator(bottomUp);
	var topDownIterator	= createIterator(topDown);

	var rootState 		= constructInitialState("rootState", nodes, rootNode);
	var successGoalState= rootState.createSuccesGoal();
	var failGoalState	= rootState.createFailGoal();

	var gHashMap:Map(String, IMA!state); //TODO: stateString as key is impractical.

	for ( nextStatus in Sequence{ IMA!StatusType#SUCCESS, IMA!StatusType#FAILED } ) {
		("Processing " + nextStatus).println(); 
		for ( be in rootState.bes.keySet() ) {
			var nextStatesBe = recur_buildIMA(	gHashMap, 
												bottomUpIterator, 
												topDownIterator, 
												rootState, 
												be.~nodeRef, 
												nextStatus );
			for ( state in nextStatesBe ) {
				("Create edge from " + rootState.toString(true) + " to " + state.toString(true) + " with edge " +  be + " and new be status " + nextStatus).println();
				rootState.setDisruption( be.~nodeRef, nextStatus, state );
			}
		}
	}
	// TODO: find all success and fail goals.
	return Sequence{ rootState, successGoalState, failGoalState };
}

operation fromLevelMapToSequence( 
			levelMap:Map(UATS!Node,Sequence) ) 
		: Sequence(UATS!Node) {
	var nbrOfLevels =  levelMap.values().max();
	var inversMap = inverseMapRelation(levelMap);
	var order = Sequence {};
	for (level in 1.to(nbrOfLevels)){
		order += inversMap.get(level);
	}
	return order;
}

// TODO: rename as it is no longer recursive!
operation recur_buildIMA(	gHashMap, 
							bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
							topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
							prevState:IMA!State, 
							be:UATS!Node, 
							nextStatus ) 
: Set(IMA!State) {

	var newState = prevState.copyState( "2" ); // TODO: maybe use state name as hash?
	// Set be to newStatus in state
	newState.setNodeStatus( be, nextStatus );

	// Calculate the statuses of this State
	// TODO: thinking in packets of work.	
	var DonePackets = Set{};
	var TodoPackets = Set{};
	var id 			= 0; 
	var packetOfWork = Sequence { newState, bottomUp.copyIterator(), be };
	TodoPackets.add( packetOfWork );
	
	while ( TodoPackets.size() > 0 ) {
		var work =  TodoPackets.random();
		("WorkPacket = " + work.first().toString(true) + " " + work.second().toString() + " " + be.id).println();
		TodoPackets.remove( work );
		// processPacketOfWork() can generate new packets of work due to raceconditions.
		var newPacketsOfWork = work.first().processPacketOfWork( work.second(), work.third() );
		DonePackets.add(work.first());
		TodoPackets.addAll( newPacketsOfWork );
		if ( TodoPackets.size() < 1 ) {
			"TodoPackets is empty.".println();		
		} else {
			"Next.".println();		
		}
		("DonePackets =" + DonePackets.size()).println();
	}

	for ( state in DonePackets ) {
		// Propogate SAFE Statuses.
		state.setSafeStatuses( bottomUp );
		// Propogate DONTCARE Statuses.
		state.propogateDontCareStatuses( topDown );
	}
	
	// Recure over new states
	for ( nextState in DonePackets ) {
		for ( nextStatus in Sequence{ IMA!StatusType#SUCCESS, IMA!StatusType#FAILED } ) {
			("Processing " + nextStatus).println(); 
			// Get remaining BEs TODO
			for ( be in nextState.getOperationalBEs() ) {
				var nextStatesBe = recur_buildIMA(	gHashMap, 
													bottomUp, 
													topDown, 
													nextState, 
													be.~nodeRef, 
													nextStatus );
				for ( state in nextStatesBe ) {
					("Create edge from" + state.toString(true) + " to " + state.toString(true) + " with edge " +  be).println();
					nextState.setDisruption( be.~nodeRef, nextStatus, state );
				}
			}
		}
	}

	return DonePackets;
}

//var packetOfWork = Set { Sequence { newState, bottomUp.copyIterator(), be } };
operation IMA!State processPacketOfWork(
	bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
	be		:UATS!Node )
: Set(Sequence) {
	var r:Set(Sequence(Any)) = Set{};
	"START_____".println();

	while ( bottomUp.hasNext() ) {
		var gate = bottomUp.next();
		var newStatuses = gate.calculateStatusInState( self, be );
		if ( newStatuses.size() == 1 ) {
			var status = newStatuses.first();
			self.setNodeStatus(gate, status);
		} else if ( newStatuses.size() > 1 ) {
			for ( newStatus in newStatuses ) {
				var newNextState = self.copyState( "R" );
				var bottomUpCopy = bottomUp.copyIterator();
				newNextState.setNodeStatus(gate, newStatus);
				r.add( Sequence{ newNextState, bottomUpCopy, be } );
			}
			self.setNodeStatus(gate, status);

		} else {
			throw ("When calculating the status of a Gate " + gate.id + " returned no status.");
		}
	}
	"STOP_____".println();
	return r;
}

operation IMA!State calculateStatusesOfGates( 
		bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
		be		:UATS!Node )
: Sequence(IMA!State) {
	var resultStates:Sequence(IMA!State);
	// Using .self to compare with previous state.
	while ( bottomUp.hasNext() ) {
		var gate = bottomUp.next();
		var newStatuses = gate.calculateStatusInState( self, be );
		for ( newStatus in newStatuses ) {
			var newNextState = self.copyState( "R" );
			//self.setNodeStatus(gate, status);
		}
	}
	return resultStates;
}
// Gate.
operation UATS!Node calculateStatusInState( state:IMA!State, be:UATS!Node )
: Set(Any) /*IMA!StatusType*/ {
	var r:Set() = Set{}; 
	var children:OrderedSet(UATS!Node) = self.children;
	
	switch (self.connector.type().name) {
		case "AND"	:{	("process AND gate!____ " + self.connector.gate.id).println();
						//self.children.println("Children___");
						if ( self.children.forAll( child |  state.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
							// If all childeren are SUCCESS return SUCCESS,
							r.add(IMA!StatusType#SUCCESS);
						} else if ( self.children.exists( child | 	state.getNodeStatus(child) == IMA!StatusType#FAILED or 
																	state.getNodeStatus(child) == IMA!StatusType#SAFE )) {
							// If any is FAILED return FAILED or SAFE,
							r.add(IMA!StatusType#FAILED);
						} else {
							// Keep gate Operational.
							"Stays OPERATIONAL!____ " + self.connector.gate.id.println();
							r.add(IMA!StatusType#OPERATIONAL);
						}
						// If DONTCARE ?? error because unexpected.
					 }
		case "OR"	:{	("process OR gate!____ " + self.connector.gate.id).println();
						r.add(IMA!StatusType#SUCCESS);
					 }	
		case "SAND"	:{	("process SAND gate!____ " + self.connector.gate.id).println();
						r.add(IMA!StatusType#SAFE);
					 }	
		default : throw (self.children.println("process UNKNOWN Gate!____" + self.connector.gate.id));
	}
	return r;
}


operation IMA!State getOperationalBEs() : Set(UATS!Node) {
	var r:Set(UATS!Node) = Set{};
	for ( be in self.bes.keySet() ) {
		if ( self.bes.get( be ) == IMA!StatusType#OPERATIONAL ) {
			r.add( be );
		}
	}
	return r;
}

operation IMA!State setSafeStatuses ( 
	bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)) )  {
	while ( bottomUp.hasNext() ) {
		var gateId = bottomUp.next().id;
		switch ( gateId.~nodeRef.connector.type().name ) {
			case "AND"	:{	("SAFE? AND gate!____ " + gateId.~nodeRef.connector.gate.id).println();
							// 
						}	
			case "OR"	:{	("SAFE? OR gate!____ " + gateId.~nodeRef.connector.gate.id).println();
							// 
						}	
			case "SAND"	:{	("SAFE? SAND gate!____ " + gateId.~nodeRef.connector.gate.id).println();
							// 
						}	
			default : throw (self.children.println("process UNKNOWN Gate!____" + gateId.~nodeRef.connector.gate.id));
		}
	}
	return;
}

operation IMA!State propogateDontCareStatuses ( 
	topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)) )  {
	while ( topDown.hasNext() ) {
		var gateId = topDown.next().id;
		switch ( gateId.~nodeRef.connector.type().name ) {
			case "AND"	:{	("DONECARE? AND gate!____ " + gateId.~nodeRef.connector.gate.id).println();
							//
						}	
			case "OR"	:{	("DONECARE? OR gate!____ " + gateId.~nodeRef.connector.gate.id).println();
							// 
						}	
			case "SAND"	:{	("DONECARE? SAND gate!____ " + gateId.~nodeRef.connector.gate.id).println();
							// 
						}	
			default : throw (self.children.println("process UNKNOWN Gate!____" + gateId.~nodeRef.connector.gate.id));
		}
	}
	return;
}


// TODO: clean up and test with SAND and SOR.
operation markGatesReachableFromBAS(
	bottomUp: Sequence(Sequence(UATS!Node), Sequence(Integer)),	 
	BEs		: Set(UATS!Node) ) {

	// Label all children using there id.
	for ( be in BEs ) {
		be.~reachableBy = Set{ be };
	}

	// For every gate add set the Union of sets of BEs which can reach the children.
	while( bottomUp.hasNext() ) {
		var gate = bottomUp.next(); 
		gate.~reachableBy = Set{};
		for ( child in gate.children ) {
			gate.~reachableBy.addAll( child.~reachableBy );
//			gate.~reachableBy.println("gate id=" + gate.id + "__");
		}
		// At this point this gate.~reachableBy contains all the BEs which are
		// able to reach this gate.
		// Next create a map which maps BEs to children.
		gate.~beToChildren = Map{};
		for ( be in gate.~reachableBy ) {
//			("..create map for be= "+ be.id +" at gate "+ gate.id).println();
			for ( child in gate.children ){
//				child.id.println("...testing child = ");
				if ( child.~reachableBy.includes( be ) ) {
//					("....Adding " + child.id + " to " + be.id).println();
					// add child to list sources reachable by BE.
					if ( gate.~beToChildren.containsKey(be) ){
//						".....Add to existing list__".println();
						var list = gate.~beToChildren.get(be);
						list.println("......list = ");
						list.add(child);
						gate.~beToChildren.put( be, list );					
					} else { // key does not jet exist. So initialize.
//						".....Create list__".println();
						var list = Set{ child };
						gate.~beToChildren.put( be, list );
					}
				} else {
//					child.id.println("...not child = ");
				}
			}
		}
//		("Gate "+gate.id+" done.").println();
		// Remove all BEs keys from Map (for this gate) which only have one
		// Child for a given BE.
//		("Removing keys containing single child in gate "+gate.id).println();
		
		gate.~beToChildrenFinal = Map{};
				
		for ( be in gate.~beToChildren.keySet() ) {
			var list = gate.~beToChildren.get( be );
			list.size().println("______  ");
			if ( list.size() > 1 ){
//				"Add to final Map".println();
				gate.~beToChildrenFinal.put( be, list);
				//gate.~beToChildren.remove( be ); //Somehow remove kills the process!
			}
		}
//		("Remaining keys containing single child in gate "+gate.id).println();
		for ( be in gate.~beToChildrenFinal.keySet() ) {
			var list = gate.~beToChildren.get( be );
//			list.size().println("______  ");
		}
		
	}
	
	// create a map from BeId to child
	
	
	
	

}

/**********************************EOF****************************************/