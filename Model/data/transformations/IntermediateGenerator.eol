import "IntermediateIterator.eol";
import "IntermediateState.eol";
import "IntermediateStateMap.eol";

operation generateIntermediateAutomata( 
			attackTree:UATS!AttackTree,
			probabilityValues:Set(UATV!attributes), // TODO: no longer required. only needed at IMA2<?>.egl  
			rootNode:UATS!Node ) 
		: IMA!InterimAutomaton {
	
	// Assotiate Gates to graph height (from bottom to top) and depth (from top to bottom)  
	var nodes	: Set(UATS!Node) = attackTree.Nodes;
	var BEs		: Set(UATS!Node) = nodes.select(n|n.children.isEmpty()).asSet();
	var bottomUp: Sequence(UATS!Node) = fromLevelMapToSequence(calculateHeightOfGates(BEs));
	var topDown	: Sequence(UATS!Node) = fromLevelMapToSequence(calculateDepthOfGates(rootNode));
	for ( be in BEs ) { topDown.add(be); } // Add BEs to the tail of the topDown iterator.

	var gates 			= nodes.excludingAll(BEs);
	var bottomUpIterator= createIterator(bottomUp);
	var topDownIterator	= createIterator(topDown);
	var gStateMap 		= createStateMap();
	var rootState 		= constructInitialState("rootState", nodes, rootNode);
	var successGoalState= rootState.createSuccesGoal();
	var failGoalState	= rootState.createFailGoal();
	var finalStates		= Map{	IMA!GoalState#SUCCESS	= successGoalState,
								IMA!GoalState#FAIL		= failGoalState};
	gStateMap.put(rootState);
	gStateMap.put(successGoalState);
	gStateMap.put(failGoalState);

	// Mark the gates in the attack-tree with a Map describing there reachability.
	markGatesReachableFromBAS( bottomUpIterator.copyIterator(), BEs );

	for ( be in rootState.bes.keySet() ) {
		// New state E representing attack / Markovian state
		// New disruption/transition from rootState to E with label BE + rate
		// New state F representing probabolistic state
		// New disruption/transition from E to F with label BE
		for ( nextStatus in Sequence{ IMA!StatusType#SUCCESS, IMA!StatusType#FAILED } ) {
			var nextStatesBe = recur_buildIMA(	gStateMap,		// hashmap containing all generated states 
												bottomUpIterator,
												topDownIterator,
												finalStates,	// the FAIL and SUCCESS automata state
												rootNode,		// attack-tree rootGate
												rootState,		// root of automata
												be.~nodeRef, 	// reference to actual attack-tree gate
												nextStatus ); 	// new node statues in next automata state. 
			// var probDivider = nextStatesBe.size();
			// if ( probDivider = 0) { delete all newly created state and disruption/transitions }
			// else {
			//	var probability = 0; 
			//	if ( nextStatus == MA!StatusType#SUCCESS ) { probability = BE.prob; } else { probability = (1 - BE.prob); }
			for ( state in nextStatesBe ) {
				/*state F.*/ rootState.setDisruption( be.~nodeRef, nextStatus, state /*, probability*/);
				
				// TODO: Not nice duplicate code. Move to recur_buildIMA ?				
				var statusType = state.getNodeStatus( rootNode );
				if ( statusType <> IMA!StatusType#OPERATIONAL ) { 	// Did the next state of the attack-tree reach the rootGoal. 
					switch (statusType) {							// If so add a transition to the final status.
						case IMA!StatusType#SUCCESS	:{ state.setDisruption( null, IMA!StatusType#SUCCESS, finalStates.get(IMA!GoalState#SUCCESS) ); }
						case IMA!StatusType#FAILED	:{ state.setDisruption( null, IMA!StatusType#FAILED, finalStates.get(IMA!GoalState#FAIL) ); }
						case IMA!StatusType#SAFE	:{ state.setDisruption( null, IMA!StatusType#FAILED, finalStates.get(IMA!GoalState#FAIL) ); }
						case IMA!StatusType#DONTCARE:{ throw ( "rootNode unexpectedly is DONTCARE" ); }
						default : throw (rootState.children.println("unknown StatusType " + statusType));
					}
				}
			}
			// } 
		} 
	}


	// Uniquely number all states.
	var disruptions:Sequence(Disruption) = IMA!Disruption.allInstances();
	generateIDForAllStates( disruptions );

	// TODO: move the code which add the rates to de IMA here when the problem
	//  is solved in which eunit is not able to handel models with dependencies.
	
	var IMA = new IMA!InterimAutomaton;	
	IMA.rootState = rootState;
	IMA.successGoal = successGoalState;
	IMA.failureGoal = failGoalState;

	var states:Sequence(IMA!State) = IMA!State.allInstances();
	for ( state in states ) {
		IMA.states.add( state );
	}

	return IMA;
}

operation fromLevelMapToSequence( 
			levelMap:Map(UATS!Node,Sequence) ) 
: Sequence(UATS!Node) {
	var nbrOfLevels =  levelMap.values().max();
	var inversMap = inverseMapRelation(levelMap);
	var order = Sequence {};
	for (level in 1.to(nbrOfLevels)){
		order += inversMap.get(level);
	}
	return order;
}

// TODO: rename
operation recur_buildIMA(	gStateMap:Map(Integer, Sequence(IMA!State)), 
							bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
							topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)),
							finalStates:Map(Any,IMA!State),/* Any is StatusType */
							rootNode:UATS!Node, 
							prevState:IMA!State, 
							be:UATS!Node, 
							nextStatus ) 
: Set(IMA!State) {
	var newState = prevState.copyState( "Generated" ); // TODO: maybe use state name as hash?
	// Set BE in state to newStatus
	newState.setNodeStatus( be, nextStatus );

	// Calculate the new statuses of the gates in this State
	var newStates = newState.calculateGateStatusesInState( bottomUp, prevState, be );
	
	var missingStates:Set(IMA!State) = Set{};
	var existingStates:Set(IMA!State) = Set{};
	var doubleStates:Set(IMA!State) = Set{};

	for ( newState in newStates ) {

		// Propogate SAFE Statuses. ()
		newState.setSafeStatuses( bottomUp.copyIterator(), be );
		// Propogate DONTCARE Statuses.
		newState.propogateDontCareStatuses( topDown.copyIterator() );

		// Check if this state already exists 
		var exists:Sequence(Boolean,IMA!State) = gStateMap.get( newState );
		
		if ( exists.first() == false ) {
			gStateMap.put( newState );
			// Add nonexisting state
			missingStates.add( newState );
		} else {
			// remember the existing state.
			existingStates.add( exists.second() );
			// forget/remove the doubles
			doubleStates.add( newState );
		}
	}

	for (state in doubleStates){
		delete state; // Make sure the double states are deleted from the model !!!
	}

	// The caller will create transitions to the state which are returned. This
	// must include the excisting state which are reached. 
	var targetStates = missingStates.includingAll( existingStates );

	//TODO: At this point the algotithm could add the egdes (Distuptions) from 
	// the rootstate(previous) to then new states target stats before continuing
	// to process these new states.  


	// Recursively process new states to create the monolithic automata.
	for ( nextState in missingStates ) {
		nextState.recur2_buildIMA( gStateMap, bottomUp, topDown, finalStates, rootNode);
	}

	return targetStates;
}

operation IMA!State recur2_buildIMA(	
							gStateMap:Map(Integer, Sequence(IMA!State)),
							bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)), 
							topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)),
							finalStates:Map(Any,IMA!State), /* Any = StatusType */
							rootNode:UATS!Node ) {

	// Get remaining BEs which are still OPERATIONAL.
	for ( be in self.getOperationalBEs() ) {
		// Process state when BE SUCCEEDS or FAILS.
		for ( nextStatus in Sequence{ IMA!StatusType#SUCCESS, IMA!StatusType#FAILED } ) {
			var nextStatesBe = recur_buildIMA(	gStateMap, 
												bottomUp,
												topDown,
												finalStates,
												rootNode,
												self,
												be.~nodeRef,
												nextStatus );
			for ( state in nextStatesBe ) { // Create an edge to the new states with BE action as a label.  
				self.setDisruption( be.~nodeRef, nextStatus, state );

				// TODO: Not nice duplicate code. Move to recur_buildIMA ?				
				var statusType = state.getNodeStatus( rootNode );
				if ( statusType <> IMA!StatusType#OPERATIONAL ) {
					// ? Does this link already exist.
					switch ( statusType ) {
						case IMA!StatusType#SUCCESS	:{ state.setDisruption( null, IMA!StatusType#SUCCESS, finalStates.get(IMA!GoalState#SUCCESS) ); }
						case IMA!StatusType#FAILED	:{ state.setDisruption( null, IMA!StatusType#FAILED, finalStates.get(IMA!GoalState#FAIL) ); }
						case IMA!StatusType#SAFE	:{ state.setDisruption( null, IMA!StatusType#FAILED, finalStates.get(IMA!GoalState#FAIL) ); }
						case IMA!StatusType#DONTCARE:{ throw ( "rootNode unexpectedly is DONTCARE" ); }
						default : throw (self.children.println("unknown StatusType " + statusType));
					}
				}
			}
		}
	}
}

operation IMA!State calculateGateStatusesInState( 
						bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)),
						prevState:IMA!State,
						be:UATS!Node ) 
						: Set(IMA!State) {
	var DonePackets = Set{};
	var TodoPackets = Set{};
	var packetOfWork = Sequence { self, bottomUp.copyIterator(), be };
	TodoPackets.add( packetOfWork );
	
	while ( TodoPackets.size() > 0 ) {
		var work =  TodoPackets.random();
		TodoPackets.remove( work );
		// processPacketOfWork() can generate new packets of work due to raceconditions.
		var resultAndnewPacketsOfWork = work.first().processPacketOfWork( work.second(), prevState, work.third() );
		var valid = resultAndnewPacketsOfWork.first();
		var newPacketsOfWork = resultAndnewPacketsOfWork.second();
		
		if ( valid ) { 
			// The last packet detected a race-condition. And as such is replaced by the new packets.
			if (newPacketsOfWork.size() == 0) {
				// activation of this 'be' did not result in any new states.
				DonePackets.add(work.first());
			} else if (newPacketsOfWork.size() == 1) {
				DonePackets.add(work.first());
			} else {
			}
		} else {
			delete self;
		}
		TodoPackets.addAll( newPacketsOfWork );
	}
	return DonePackets; // set of new target AT states.
}

operation IMA!State processPacketOfWork(
	bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)),
	prevState:IMA!State, 
	be		:UATS!Node )
: Collection(Boolean,Set(Sequence)) { /* = Set { Sequence { newState, bottomUp.copyIterator(), be } } */
	var r:Set(Sequence(Any)) = Set{};
	var valid = true;

	while ( bottomUp.hasNext() and valid ) { // Iterate over gates.
		var gate = bottomUp.next(); // Next gate
		var ValidAndnewStatuses = gate.calculateStatusInState( self, prevState, be );

		if( ValidAndnewStatuses.first() == true ){ // valid 'be' activation.
			var newStatuses = ValidAndnewStatuses.second();
			if ( newStatuses.size() == 1 ) {// Changing 'be' in the current state did
				var status = newStatuses.first();
				self.setNodeStatus(gate, status);
			} else if ( newStatuses.size() > 1 ) {	// Racecondition occured.
				for ( newStatus in newStatuses ) {
					// Create a packet of work for all possible statuses 
					// to be processed in the future.
					var newNextState = self.copyState( "R" );
					var bottomUpCopy = bottomUp.copyIterator();
					newNextState.setNodeStatus(gate, newStatus);
									
					r.add( Sequence{ newNextState, bottomUpCopy, be } );
				}
			} else {
				// When calculating the status of a Gate when 'be' changed returned no status.
			}
		} else { // invalid 'be' activation.
			valid = false;
			r = Set{};
		}
	} // State 'self' is processed in the bottom-up direction

	return Collection{valid,r}; // New work packets due to race condition.
}

          // Gate.
operation UATS!Node calculateStatusInState( state:IMA!State, prevState:IMA!State, be:UATS!Node )
: Collection(Boolean,Set(Any)) /*IMA!StatusType*/ {
	//var invalid = false;
	//var r:Set() = Set{};
	switch (self.connector.type().name) {
		case "AND"	:{ return Collection{ true, Set{ state.calculateStatusOfAND(self) } }; }
		case "OR"	:{ return Collection{ true, Set{ state.calculateStatusOfOR(self) } }; }	
		case "SAND"	:{ return state.calculateStatusOfSequentialGate(self, prevState, be ); }
		case "SOR"	:{ return state.calculateStatusOfSequentialGate(self, prevState, be ); }
		case "PAND"	:{ return state.calculateStatusOfSequentialGate(self, prevState, be ); }
		case "POR"	:{ return state.calculateStatusOfSequentialGate(self, prevState, be ); }
		default : throw (self.children.println("process UNKNOWN Gate type!____" 
						+ self.connector.gate.id));
	}
}

operation IMA!State calculateStatusOfAND( gate:UATS!Node )
: Any /*IMA!StatusType*/ {
	if ( gate.children.forAll( child |  self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		// If all childeren are SUCCESS return SUCCESS,
		return IMA!StatusType#SUCCESS;
	} else if ( gate.children.exists( child | 
					self.getNodeStatus(child) == IMA!StatusType#FAILED )) {
		// If any has failed is FAILED return FAILED,
		return IMA!StatusType#FAILED;
	} else if ( gate.children.exists( child | 
					self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
		// If any is SAFE return SAFE,
		return IMA!StatusType#SAFE;
	} else {
		// Keep gate Operational.
		return IMA!StatusType#OPERATIONAL;
	}
	// If DONTCARE ?? error because unexpected.
}

operation IMA!State calculateStatusOfOR( gate:UATS!Node )
: Any /*IMA!StatusType*/ {
	if ( gate.children.exists(
			child | self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		// If any child is SUCCESS return SUCCESS,
		return IMA!StatusType#SUCCESS;
	} else if ( gate.children.forAll(
			child | self.getNodeStatus(child) == IMA!StatusType#FAILED
					or self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
		// If all are FAILED of SAFE return FAILED,
		return IMA!StatusType#FAILED;
	} else {
		// Keep gate Operational.
		return IMA!StatusType#OPERATIONAL;
	}
}

// TODO: How are possible race conditions implemented in DFTCalc and STORM?
operation IMA!State calculateStatusOfSequentialGate( gate:UATS!Node, prevState:IMA!State, be:UATS!Node )
: Collection(Boolean,Set(Any)) /* Set(IMA!StatusType) */ {
	var out = Set{};
	var statuses = Set{};
	var validActivation = true;
	//	gate.~beToChildrenFinal: describes via which children of the gate BE can
	//  reach the gate. It only mentions BEs which can reach the gate via multiple
	//  children resulting in race conditions. This information is only of importance
	//  to SAND and SOR gates.
	if ( self.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL ) {
		// First test if childeren of this gate are activated out of order.
		if ( gate.connector.type().name == "SAND" or gate.connector.type().name == "SOR" ) {
			validActivation = self.isActivatedFromLeft( gate, be );
		}
		
		if ( validActivation ) {
			// If not activated out of order handle potential race condition. 
			var bes = gate.~beToChildrenFinal.keySet(); // retrieve 'be' which participate in the racecondition.
			if ( bes.includes( be ) and (prevState <> null) ) { // TODO prevent passing null.
				// Because 'be' can reach this gate via multiple children activation of
				// this 'be' could possibly generate multiple outcomes
				// Now check what happens when only one child is changed before all others.
				
				// Create a temperary state in which the childeren of this gate are reset.
				// 1. Copy children from previous state
				var resetState = self.copyState("resetState");
		
				// 2. Reset children which participate in a race condition to the 
				//    previous status.
				for ( childB in gate.~beToChildrenFinal.get( be ) ) {
					var prevStatus = prevState.getNodeStatus( childB );
					resetState.setNodeStatus( childB, prevStatus );
				}
		
				// TODO: move to upfront calculation to start of generateIntermediateAutomata()
				var childSequences = gate.~sequences;
				// Generate the cartesian product of orders in which the changes of the 'bes' can occure.
				// var childSequences = gate.~beToChildrenFinal.get( be ).asSequence().combinations();
				
				// Calculate all possible statues.
				for ( childSequence in childSequences ) {
				
					var tempState = resetState.copyState("tempState");
					var newStatus = IMA!StatusType#OPERATIONAL;
					// Determine the status when childere are set in the sequence.
					for ( child in childSequence ) {
						var newChildStatus = self.getNodeStatus( child );
						tempState.setNodeStatus( child, newChildStatus );
						if ( tempState.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL) {
							switch (gate.connector.type().name) {
								case "SAND"	:{ newStatus = tempState.calculatedStatusOfSAND( gate );}
								case "SOR"	:{ newStatus = tempState.calculatedStatusOfSOR( gate ); }
								case "PAND"	:{ newStatus = tempState.calculatedStatusOfSAND( gate ); }
								case "POR"	:{ newStatus = tempState.calculatedStatusOfSOR( gate ); }
								default : throw (self.children.println("process UNKNOWN Gate!____" 
												+ self.connector.gate.id));
							}
							if ( newStatus <> IMA!StatusType#OPERATIONAL ) {
								statuses.add( newStatus );  // When the status changes we
								break;						// are done for this activation sequence.
							}
						} else {
							newStatus = tempState.getNodeStatus(gate);
							statuses.add( tempState.getNodeStatus(gate) );
						}
					}
					// After completion of a sequence the gate state is still OPERATIONAL.
					// This should be added as on off the new states.
					if ( newStatus == IMA!StatusType#OPERATIONAL ) {
						statuses.add( newStatus );
					}
					delete tempState;
				}
				delete resetState;
			} else {
				// No race-condition.
				if ( self.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL) {
					switch (gate.connector.type().name) {
						case "SAND"	:{ statuses.add( self.calculatedStatusOfSAND( gate ) ); }
						case "SOR"	:{ statuses.add( self.calculatedStatusOfSOR( gate ) ); }
						case "PAND"	:{ statuses.add( self.calculatedStatusOfSAND( gate ) ); }
						case "POR"	:{ statuses.add( self.calculatedStatusOfSOR( gate ) ); }
						default : throw (self.children.println("process UNKNOWN Gate!____" 
										+ self.connector.gate.id));
					}
				} else {
					statuses.add( self.getNodeStatus(gate) );
				}
			}
		} else {
			// Skip gate as its allready changes state.
		}
		// At this point 'statuses' contains all statuses which can occure for 
		// this gate during this transition.
		if ( (gate.connector.type().name == "SAND") 
			or (gate.connector.type().name == "SOR" )) {
			out = statuses.excluding( IMA!StatusType#OPERATIONAL );
			
			if ( (out.size() == 1) and (statuses.first() == IMA!StatusType#SAFE) ) {
				validActivation = false;
			} else if ( statuses.size() > 1 ) {
				out = statuses.excluding( IMA!StatusType#SAFE );
			}
		} else {
			out = statuses;
		}
	}
	// Also test if OPERATIONAL is the only other status the also invalid.
	// TODO recalculate probabilities id only one option!!!
	return Collection{validActivation, out};
}

operation IMA!State calculatedStatusOfSAND( gate:UATS!Node ) 
:Any /* Set(IMA!StatusType) */ {
	if ( self.isActivatedFromLeft( gate.children ) == false ) {
		return IMA!StatusType#SAFE;
	}

	if ( gate.children.forAll( child |  self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		return IMA!StatusType#SUCCESS;
	} else if ( gate.children.exists( child | 
					self.getNodeStatus(child) == IMA!StatusType#FAILED
					or self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
		// If any is FAILED return FAILED,
		return IMA!StatusType#FAILED;
	}
	
	return IMA!StatusType#OPERATIONAL;
}

operation IMA!State calculatedStatusOfSOR( gate:UATS!Node )
: Any /*IMA!StatusType*/ {
	if ( self.isActivatedFromLeft( gate.children ) == false ) {
		return IMA!StatusType#SAFE;
	}

	if ( gate.children.exists(
			child | self.getNodeStatus(child) == IMA!StatusType#SUCCESS ) ) {
		// If any child is SUCCESS return SUCCESS,
		return IMA!StatusType#SUCCESS;
	} else if ( gate.children.forAll(
			child | self.getNodeStatus(child) == IMA!StatusType#FAILED
					or self.getNodeStatus(child) == IMA!StatusType#SAFE )) {
		// If all are FAILED of SAFE return FAILED,
		return IMA!StatusType#FAILED;
	}

	return IMA!StatusType#OPERATIONAL;
}

operation IMA!State isActivatedFromLeft( children:OrderedSet(UATS!Node) ) : Boolean {  
	var next = 0;
	while ( (next <= children.size() - 1 ) // Search first child which is not yet activated 
			and ( self.getNodeStatus( children.at( next ) ) <> IMA!StatusType#OPERATIONAL ) ) {
		next++;
	}
	if ( next > children.size() - 1 ) { // If all children are activated order is correct.
		return true;
	} else { 							// Else some are stil not activated.
										// From here all must be unactivated
		while ( ( next <= children.size() - 1 ) 
				and( self.getNodeStatus( children.at( next ) ) == IMA!StatusType#OPERATIONAL ) ) {
			next++;
		}
		if ( next > children.size() - 1 ) { // All remaining children remain unactivated.
			return true;
		} else { 							// Detected yet an activated child after an
			return false;					// unactivated child.
		}
	}
}

operation IMA!State isActivatedFromLeft( gate:UATS!Node, be:UATS!Node ) : Boolean {
	// get children reachable by the current 'be'.
	// Collect all 'bes' which can reach this gate.
	var next = Set{};
	var prev = Set{};
	for ( child in gate.children ) {
		next = next.includingAll( child.~reachableBy );
	}
	
	for ( child in gate.children ) {
		prev = prev.includingAll( child.~reachableBy ); 
		next = next.excludingAll( child.~reachableBy );
		if (	( self.getNodeStatus( child ) == IMA!StatusType#OPERATIONAL )
			and ( not prev.includes( be ) )
			and ( next.includes( be ) ) 
		) {
			return false;
		}
	}
	return true;
}


operation IMA!State getOperationalBEs() : Set(UATS!Node) {
	var r:Set(UATS!Node) = Set{};
	for ( be in self.bes.keySet() ) {
		if ( self.bes.get( be ) == IMA!StatusType#OPERATIONAL ) {
			r.add( be );
		}
	}
	return r;
}

// TODO: Should this function be called again and again intil there no longer is a change.
operation IMA!State setSafeStatuses ( 
	bottomUp:Sequence(Sequence(UATS!Node), Sequence(Integer)),
	be:UATS!Node )  {
	while ( bottomUp.hasNext() ) {
		var gate = bottomUp.next();
		if ( self.getNodeStatus(gate) <> IMA!StatusType#OPERATIONAL ) {
			// Gate already changed.
		} else {
			switch ( gate.connector.type().name ) {
				case "AND"	:{	var status = self.calculateStatusOfAND( gate ); }	
				case "OR"	:{	var status = self.calculateStatusOfOR( gate ); }	
				case "SAND"	:{	// NOTE: When a race condition has occured 
								// recalculating the status of a SAND could 
								// potentially generate an excisting state 
								// which will subsequantly be removed. 
								var status = self.calculatedStatusOfSAND( gate );
							}	
				case "SOR"	:{	// NOTE: When a race condition has occured 
								// recalculating the status of a SOR could 
								// potentially generate an excisting state 
								// which will subsequantly be removed. 
								var status = self.calculatedStatusOfSOR( gate );
							}	
				case "PAND"	:{	// NOTE: When a race condition has occured 
								// recalculating the status of a PAND could 
								// potentially generate an excisting state 
								// which will subsequantly be removed. 
								var status = self.calculatedStatusOfSAND( gate );
							}	
				case "POR"	:{	// NOTE: When a race condition has occured 
								// recalculating the status of a POR could 
								// potentially generate an excisting state 
								// which will subsequantly be removed. 
								var status = self.calculatedStatusOfSOR( gate );
							}	
				default : throw (self.children.println("process UNKNOWN Gate!____" + gate.connector.gate.id));
			}
			if ( ( status == IMA!StatusType#FAILED ) 
				or ( status == IMA!StatusType#SAFE ) ) {
				self.setNodeStatus(gate, IMA!StatusType#SAFE);
			}
		}
	}
}

operation IMA!State propogateDontCareStatuses ( 
	topDown:Sequence(Sequence(UATS!Node), Sequence(Integer)) )  {
	while ( topDown.hasNext() ) {
		var gate = topDown.next();
		if ( self.getNodeStatus(gate) == IMA!StatusType#OPERATIONAL ) { 
			var parents = gate.parents;
			if (parents.size() > 0) {
				if ( parents.forAll( parent |  self.getNodeStatus(parent) <> IMA!StatusType#OPERATIONAL ) ) {
					// DONTCARE propogates.
					self.setNodeStatus(gate, IMA!StatusType#DONTCARE);
				}
			}
		}			
	}
}

operation childrenActivatedInOrder( gate:UATS!Node ) {
	
	
}

// TODO: clean up and test with SAND and SOR.
operation markGatesReachableFromBAS(
	bottomUp: Sequence(Sequence(UATS!Node), Sequence(Integer)),	 
	BEs		: Set(UATS!Node) ) {

	// Label all children using there id.
	for ( be in BEs ) {
		be.~reachableBy = Set{ be };
	}
	// For every gate add set the Union of sets of BEs which can reach the children.
	while( bottomUp.hasNext() ) {
		var gate = bottomUp.next(); 
		gate.~reachableBy = Set{};
		for ( child in gate.children ) {
			gate.~reachableBy.addAll( child.~reachableBy );
		}
		// At this point this gate.~reachableBy contains all the BEs which are
		// able to reach this gate.
		// Next create a map which maps BEs to children.
		gate.~beToChildren = Map{}; /* Map(UATS!Node,Sequence(UATS!Node)) */ 
		for ( be in gate.~reachableBy ) {
			for ( child in gate.children ){
				if ( child.~reachableBy.includes( be ) ) {
					// add child to list sources reachable by BE.
					if ( gate.~beToChildren.containsKey(be) ){
						// Add to existing list;
						var list = gate.~beToChildren.get(be);
						list.add(child);
						gate.~beToChildren.put( be, list );					
					} else { // key does not jet exist. So initialize.
						var list = Set{ child };
						gate.~beToChildren.put( be, list );
					}
				} else {
					// Not child
				}
			}
		}
		// Remove all BEs keys from Map (for this gate) which only have one
		// Child for a given BE.
		gate.~beToChildrenFinal = Map{};
				
		for ( be in gate.~beToChildren.keySet() ) {
			var list = gate.~beToChildren.get( be );
			if ( list.size() > 1 ){
				gate.~beToChildrenFinal.put( be, list);
				// Create set of possible child activation sequences. 
				// And also add this as an Extended Proplerty.  	 
				gate.~sequences = gate.~beToChildrenFinal.get( be ).asSequence().combinations();
			}
		}
		
		delete gate.~beToChildren;
	}
	
	// Label remove be.~reachableBy which is no longer needed.
	for ( be in BEs ) {
		// TODO: This seems to also delete be.id which is required?
		// delete be.~reachableBy; 
	}
}

operation generateIDForAllStates( disruptions:Sequence(IMA!Disruption) ) {
	var id:Integer = 3;
	
	for (disruption:IMA!Disruption in disruptions) {
		// set id of source state in not set
	
		if ( disruption.source.id == -1 ) {
			disruption.source.id = id;
			if ( ( disruption.source.name <> IMA!GoalState#FAIL.toString() ) 
				and ( disruption.source.name <> IMA!GoalState#SUCCESS.toString() ) ) {
				disruption.source.name = id.toString();
			}
			id++;
		}

		// set id of target state in not set
		if ( disruption.target.id == -1 ) {
			disruption.target.id = id;
			if ( ( disruption.target.name <> IMA!GoalState#FAIL.toString() ) 
				and ( disruption.target.name <> IMA!GoalState#SUCCESS.toString() ) ) {
				disruption.target.name = id.toString();
			}
			id++;
		}
	}
}

/**********************************EOF****************************************/